# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

class BasicObject
  def __binding__(); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

class BufferedTokenizer
  def extract(data); end

  def flush(); end

  def initialize(delimiter=T.unsafe(nil)); end
end

class BufferedTokenizer
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

module Concurrent
  AtExit = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExchanger
  def exchange(value, timeout=T.unsafe(nil)); end

  def exchange!(value, timeout=T.unsafe(nil)); end

  def try_exchange(value, timeout=T.unsafe(nil)); end
end

class Concurrent::AbstractExchanger
end

class Concurrent::AbstractExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def auto_terminate=(value); end

  def auto_terminate?(); end

  def fallback_policy(); end

  def initialize(*args, &block); end

  def kill(); end

  def running?(); end

  def shutdown(); end

  def shutdown?(); end

  def shuttingdown?(); end

  def wait_for_termination(timeout=T.unsafe(nil)); end
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
end

class Concurrent::AbstractThreadLocalVar
  def allocate_storage(); end

  def bind(value, &block); end

  def default(); end

  def initialize(default=T.unsafe(nil), &default_block); end

  def value(); end

  def value=(value); end
end

class Concurrent::AbstractThreadLocalVar
end

class Concurrent::Agent
  include ::Concurrent::Concern::Observable
  def <<(action); end

  def await(); end

  def await_for(timeout); end

  def await_for!(timeout); end

  def deref(); end

  def error(); end

  def error_mode(); end

  def failed?(); end

  def initialize(initial, opts=T.unsafe(nil)); end

  def post(*args, &action); end

  def reason(); end

  def restart(new_value, opts=T.unsafe(nil)); end

  def send(*args, &action); end

  def send!(*args, &action); end

  def send_off(*args, &action); end

  def send_off!(*args, &action); end

  def send_via(executor, *args, &action); end

  def send_via!(executor, *args, &action); end

  def stopped?(); end

  def value(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
  def initialize(message=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent
  def self.await(*agents); end

  def self.await_for(timeout, *agents); end

  def self.await_for!(timeout, *agents); end
end

class Concurrent::Array
end

class Concurrent::Array
end

module Concurrent::Async
  def async(); end

  def await(); end

  def call(); end

  def cast(); end

  def init_synchronization(); end
end

module Concurrent::Async
  def self.included(base); end

  def self.validate_argc(obj, method, *args); end
end

class Concurrent::Atom
  include ::Concurrent::Concern::Observable
  def compare_and_set(old_value, new_value); end

  def deref(); end

  def initialize(value, opts=T.unsafe(nil)); end

  def reset(new_value); end

  def swap(*args); end

  def value(); end
end

class Concurrent::Atom
  def self.new(*args, &block); end
end

class Concurrent::AtomicBoolean
end

class Concurrent::AtomicBoolean
end

module Concurrent::AtomicDirectUpdate
  def try_update(); end

  def try_update!(); end

  def update(); end
end

module Concurrent::AtomicDirectUpdate
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicMarkableReference
  def compare_and_set(expected_val, new_val, expected_mark, new_mark); end

  def compare_and_swap(expected_val, new_val, expected_mark, new_mark); end

  def get(); end

  def initialize(value=T.unsafe(nil), mark=T.unsafe(nil)); end

  def mark(); end

  def marked?(); end

  def set(new_val, new_mark); end

  def try_update(); end

  def try_update!(); end

  def update(); end

  def value(); end
end

class Concurrent::AtomicMarkableReference
  def self.new(*args, &block); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
end

class Concurrent::AtomicReference
end

class Concurrent::AtomicReference
end

class Concurrent::CachedThreadPool
end

class Concurrent::CachedThreadPool
end

class Concurrent::CancelledOperationError
end

class Concurrent::CancelledOperationError
end

module Concurrent::Collection
end

class Concurrent::Collection::CopyOnNotifyObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnNotifyObserverSet
end

class Concurrent::Collection::CopyOnWriteObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnWriteObserverSet
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
end

class Concurrent::Collection::NonConcurrentMapBackend
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end

  def clear(); end

  def delete(item); end

  def deq(); end

  def empty?(); end

  def enq(item); end

  def has_priority?(item); end

  def include?(item); end

  def initialize(opts=T.unsafe(nil)); end

  def length(); end

  def peek(); end

  def pop(); end

  def push(item); end

  def shift(); end

  def size(); end
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def self.from_list(list, opts=T.unsafe(nil)); end
end

module Concurrent::Collection
end

module Concurrent::Concern
end

module Concurrent::Concern::Dereferenceable
  def apply_deref_options(value); end

  def deref(); end

  def ns_set_deref_options(opts); end

  def set_deref_options(opts=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

module Concurrent::Concern::Dereferenceable
end

module Concurrent::Concern::Logging
  include ::Logger::Severity
  def log(level, progname, message=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Logging
end

module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def compare_and_set_state(next_state, *expected_current); end

  def complete?(); end

  def event(); end

  def exception(*args); end

  def fulfilled?(); end

  def get_arguments_from(opts=T.unsafe(nil)); end

  def if_state(*expected_states); end

  def incomplete?(); end

  def init_obligation(); end

  def no_error!(timeout=T.unsafe(nil)); end

  def ns_check_state?(expected); end

  def ns_set_state(value); end

  def pending?(); end

  def realized?(); end

  def reason(); end

  def rejected?(); end

  def set_state(success, value, reason); end

  def state(); end

  def state=(value); end

  def unscheduled?(); end

  def value(timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end
end

module Concurrent::Concern::Obligation
end

module Concurrent::Concern::Observable
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def observers(); end

  def observers=(observers); end

  def with_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Observable
end

module Concurrent::Concern
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::ConcurrentUpdateError
end

class Concurrent::ConfigurationError
end

class Concurrent::ConfigurationError
end

class Concurrent::CountDownLatch
end

class Concurrent::CountDownLatch
end

class Concurrent::CyclicBarrier
  def broken?(); end

  def initialize(parties, &block); end

  def ns_generation_done(generation, status, continue=T.unsafe(nil)); end

  def ns_initialize(parties, &block); end

  def ns_next_generation(); end

  def number_waiting(); end

  def parties(); end

  def reset(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::CyclicBarrier
end

class Concurrent::Delay
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def initialize(opts=T.unsafe(nil), &block); end

  def ns_initialize(opts, &block); end

  def reconfigure(&block); end
end

class Concurrent::Delay
end

class Concurrent::DependencyCounter
  def initialize(count, &block); end

  def update(time, value, reason); end
end

class Concurrent::DependencyCounter
end

class Concurrent::Error
end

class Concurrent::Error
end

class Concurrent::Event
  def initialize(); end

  def ns_initialize(); end

  def ns_set(); end

  def reset(); end

  def set(); end

  def set?(); end

  def try?(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Event
end

class Concurrent::Exchanger
end

class Concurrent::Exchanger
end

module Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def <<(task); end

  def can_overflow?(); end

  def post(*args, &task); end

  def serialized?(); end
end

module Concurrent::ExecutorService
end

class Concurrent::FixedThreadPool
  def initialize(num_threads, opts=T.unsafe(nil)); end
end

class Concurrent::FixedThreadPool
end

class Concurrent::Future
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def set(value=T.unsafe(nil), &block); end

  def wait_or_cancel(timeout); end
end

class Concurrent::Future
  def self.execute(opts=T.unsafe(nil), &block); end
end

class Concurrent::Hash
end

class Concurrent::Hash
end

class Concurrent::IVar
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def check_for_block_or_value!(block_given, value); end

  def complete(success, value, reason); end

  def complete_without_notification(success, value, reason); end

  def fail(reason=T.unsafe(nil)); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def notify_observers(value, reason); end

  def ns_complete_without_notification(success, value, reason); end

  def ns_initialize(value, opts); end

  def safe_execute(task, args=T.unsafe(nil)); end

  def set(value=T.unsafe(nil)); end

  def try_set(value=T.unsafe(nil), &block); end
end

class Concurrent::IVar
end

class Concurrent::IllegalOperationError
end

class Concurrent::IllegalOperationError
end

class Concurrent::ImmediateExecutor
  include ::Concurrent::SerialExecutorService
  def initialize(); end
end

class Concurrent::ImmediateExecutor
end

class Concurrent::ImmutabilityError
end

class Concurrent::ImmutabilityError
end

module Concurrent::ImmutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::ImmutableStruct
  def self.included(base); end

  def self.new(*args, &block); end
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::InitializationError
end

class Concurrent::InitializationError
end

class Concurrent::LifecycleError
end

class Concurrent::LifecycleError
end

class Concurrent::LockFreeStack
  include ::Enumerable
  def clear(); end

  def clear_each(&block); end

  def clear_if(head); end

  def compare_and_clear(head); end

  def compare_and_pop(head); end

  def compare_and_push(head, value); end

  def each(head=T.unsafe(nil), &blk); end

  def empty?(head=T.unsafe(nil)); end

  def initialize(head=T.unsafe(nil)); end

  def peek(); end

  def pop(); end

  def push(value); end

  def replace_if(head, new_head); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack::Node
  def initialize(value, next_node); end

  def next_node(); end

  def value(); end

  def value=(value); end
end

class Concurrent::LockFreeStack::Node
  def self.[](*_); end
end

class Concurrent::LockFreeStack
  def self.new(*args, &block); end

  def self.of1(value); end

  def self.of2(value1, value2); end
end

class Concurrent::MVar
  include ::Concurrent::Concern::Dereferenceable
  def borrow(timeout=T.unsafe(nil)); end

  def empty?(); end

  def full?(); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil)); end

  def modify(timeout=T.unsafe(nil)); end

  def modify!(); end

  def put(value, timeout=T.unsafe(nil)); end

  def set!(value); end

  def synchronize(&block); end

  def take(timeout=T.unsafe(nil)); end

  def try_put!(value); end

  def try_take!(); end
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  def self.new(*args, &block); end
end

class Concurrent::Map
  def each(&blk); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def value?(value); end

  def values(); end
end

class Concurrent::Map
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::Maybe
  include ::Comparable
  def fulfilled?(); end

  def initialize(just, nothing); end

  def just(); end

  def just?(); end

  def nothing(); end

  def nothing?(); end

  def or(other); end

  def reason(); end

  def rejected?(); end

  def value(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  def self.from(*args); end

  def self.just(value); end

  def self.nothing(error=T.unsafe(nil)); end
end

class Concurrent::MultipleAssignmentError
  def initialize(message=T.unsafe(nil), inspection_data=T.unsafe(nil)); end

  def inspection_data(); end
end

class Concurrent::MultipleAssignmentError
end

class Concurrent::MultipleErrors
  def errors(); end

  def initialize(errors, message=T.unsafe(nil)); end
end

class Concurrent::MultipleErrors
end

module Concurrent::MutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::MutableStruct
  def self.new(*args, &block); end
end

class Concurrent::MutexAtomicBoolean
  def false?(); end

  def initialize(initial=T.unsafe(nil)); end

  def make_false(); end

  def make_true(); end

  def ns_initialize(initial); end

  def true?(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicBoolean
end

class Concurrent::MutexAtomicFixnum
  def compare_and_set(expect, update); end

  def decrement(delta=T.unsafe(nil)); end

  def down(delta=T.unsafe(nil)); end

  def increment(delta=T.unsafe(nil)); end

  def initialize(initial=T.unsafe(nil)); end

  def ns_initialize(initial); end

  def up(delta=T.unsafe(nil)); end

  def update(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicFixnum
end

class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper
  def _compare_and_set(old_value, new_value); end

  def compare_and_swap(old_value, new_value); end

  def get(); end

  def get_and_set(new_value); end

  def initialize(value=T.unsafe(nil)); end

  def ns_initialize(value); end

  def set(new_value); end

  def swap(new_value); end

  def value(); end

  def value=(new_value); end
end

class Concurrent::MutexAtomicReference
end

class Concurrent::MutexCountDownLatch
  def count(); end

  def count_down(); end

  def initialize(count=T.unsafe(nil)); end

  def ns_initialize(count); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::MutexCountDownLatch
end

class Concurrent::MutexSemaphore
  def acquire(permits=T.unsafe(nil)); end

  def available_permits(); end

  def drain_permits(); end

  def initialize(count); end

  def ns_initialize(count); end

  def reduce_permits(reduction); end

  def release(permits=T.unsafe(nil)); end

  def try_acquire(permits=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Concurrent::MutexSemaphore
end

module Concurrent::Options
end

module Concurrent::Options
  def self.executor(executor_identifier); end

  def self.executor_from_options(opts=T.unsafe(nil)); end
end

class Concurrent::Promise
  def catch(&block); end

  def execute(); end

  def flat_map(&block); end

  def initialize(opts=T.unsafe(nil), &block); end

  def notify_child(child); end

  def on_error(&block); end

  def on_fulfill(result); end

  def on_reject(reason); end

  def on_success(&block); end

  def realize(task); end

  def rescue(&block); end

  def root?(); end

  def set(value=T.unsafe(nil), &block); end

  def set_pending(); end

  def set_state!(success, value, reason); end

  def synchronized_set_state!(success, value, reason); end

  def then(*args, &block); end

  def zip(*others); end
end

class Concurrent::Promise
  def self.aggregate(method, *promises); end

  def self.all?(*promises); end

  def self.any?(*promises); end

  def self.execute(opts=T.unsafe(nil), &block); end

  def self.fulfill(value, opts=T.unsafe(nil)); end

  def self.reject(reason, opts=T.unsafe(nil)); end

  def self.zip(*promises); end
end

class Concurrent::PromiseExecutionError
end

class Concurrent::PromiseExecutionError
end

module Concurrent::Promises
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
  def add_callback_clear_delayed_node(node); end

  def add_callback_notify_blocked(promise, index); end

  def blocks(); end

  def callbacks(); end

  def chain(*args, &task); end

  def chain_on(executor, *args, &task); end

  def chain_resolvable(resolvable); end

  def default_executor(); end

  def initialize(promise, default_executor); end

  def internal_state(); end

  def on_resolution(*args, &callback); end

  def on_resolution!(*args, &callback); end

  def on_resolution_using(executor, *args, &callback); end

  def pending?(); end

  def promise(); end

  def resolve_with(state, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolved?(); end

  def state(); end

  def tangle(resolvable); end

  def touch(); end

  def touched?(); end

  def wait(timeout=T.unsafe(nil)); end

  def waiting_threads(); end

  def with_default_executor(executor); end

  def with_hidden_resolvable(); end
end

class Concurrent::Promises::AbstractEventFuture
  def self.new(*args, &block); end
end

class Concurrent::Promises::Event
  def &(other); end

  def any(event_or_future); end

  def delay(); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def to_event(); end

  def to_future(); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Event
end

module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  def any(*futures_and_or_events); end

  def any_event(*futures_and_or_events); end

  def any_event_on(default_executor, *futures_and_or_events); end

  def any_fulfilled_future(*futures_and_or_events); end

  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  def any_resolved_future(*futures_and_or_events); end

  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  def delay(*args, &task); end

  def delay_on(default_executor, *args, &task); end

  def fulfilled_future(value, default_executor=T.unsafe(nil)); end

  def future(*args, &task); end

  def future_on(default_executor, *args, &task); end

  def make_future(argument=T.unsafe(nil), default_executor=T.unsafe(nil)); end

  def rejected_future(reason, default_executor=T.unsafe(nil)); end

  def resolvable_event(); end

  def resolvable_event_on(default_executor=T.unsafe(nil)); end

  def resolvable_future(); end

  def resolvable_future_on(default_executor=T.unsafe(nil)); end

  def resolved_event(default_executor=T.unsafe(nil)); end

  def resolved_future(fulfilled, value, reason, default_executor=T.unsafe(nil)); end

  def schedule(intended_time, *args, &task); end

  def schedule_on(default_executor, intended_time, *args, &task); end

  def zip(*futures_and_or_events); end

  def zip_events(*futures_and_or_events); end

  def zip_events_on(default_executor, *futures_and_or_events); end

  def zip_futures(*futures_and_or_events); end

  def zip_futures_on(default_executor, *futures_and_or_events); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  def default_executor(); end
end

module Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::Promises::FactoryMethods
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

class Concurrent::Promises::Future
  def &(other); end

  def any(event_or_future); end

  def apply(args, block); end

  def delay(); end

  def exception(*args); end

  def flat(level=T.unsafe(nil)); end

  def flat_event(); end

  def flat_future(level=T.unsafe(nil)); end

  def fulfilled?(); end

  def on_fulfillment(*args, &callback); end

  def on_fulfillment!(*args, &callback); end

  def on_fulfillment_using(executor, *args, &callback); end

  def on_rejection(*args, &callback); end

  def on_rejection!(*args, &callback); end

  def on_rejection_using(executor, *args, &callback); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def rejected?(); end

  def rescue(*args, &task); end

  def rescue_on(executor, *args, &task); end

  def result(timeout=T.unsafe(nil)); end

  def run(run_test=T.unsafe(nil)); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def then_on(executor, *args, &task); end

  def to_event(); end

  def to_future(); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Future
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
end

class Concurrent::Promises::ResolvableEvent
  include ::Concurrent::Promises::Resolvable
  def resolve(raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableEvent
end

class Concurrent::Promises::ResolvableFuture
  include ::Concurrent::Promises::Resolvable
  def evaluate_to(*args, &block); end

  def evaluate_to!(*args, &block); end

  def fulfill(value, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def reject(reason, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolve(fulfilled=T.unsafe(nil), value=T.unsafe(nil), reason=T.unsafe(nil), raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def result(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableFuture
end

module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::ReInclude
  def extended(base); end

  def include(*modules); end

  def included(base); end
end

module Concurrent::ReInclude
end

class Concurrent::ReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def has_waiters?(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end

  def write_locked?(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::ReentrantReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def try_read_lock(); end

  def try_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::RejectedExecutionError
end

class Concurrent::RejectedExecutionError
end

class Concurrent::ResourceLimitError
end

class Concurrent::ResourceLimitError
end

class Concurrent::RubyExchanger
  def compare_and_set_slot(expected, value); end

  def slot(); end

  def slot=(value); end

  def swap_slot(value); end

  def update_slot(&block); end
end

class Concurrent::RubyExchanger
  def self.new(*args, &block); end
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubyThreadLocalVar
end

class Concurrent::RubyThreadLocalVar
  def self.thread_finalizer(array); end

  def self.threadlocal_finalizer(index); end
end

class Concurrent::RubyThreadPoolExecutor
  def completed_task_count(); end

  def idletime(); end

  def initialize(opts=T.unsafe(nil)); end

  def largest_length(); end

  def length(); end

  def max_length(); end

  def max_queue(); end

  def min_length(); end

  def queue_length(); end

  def ready_worker(worker); end

  def remaining_capacity(); end

  def remove_busy_worker(worker); end

  def scheduled_task_count(); end

  def worker_died(worker); end

  def worker_not_old_enough(worker); end

  def worker_task_completed(); end
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
end

class Concurrent::SafeTaskExecutor
  def execute(*args); end

  def initialize(task, opts=T.unsafe(nil)); end
end

class Concurrent::SafeTaskExecutor
end

class Concurrent::ScheduledTask
  include ::Comparable
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def executor(); end

  def initial_delay(); end

  def initialize(delay, opts=T.unsafe(nil), &task); end

  def ns_reschedule(delay); end

  def ns_schedule(delay); end

  def process_task(); end

  def processing?(); end

  def reschedule(delay); end

  def reset(); end

  def schedule_time(); end
end

class Concurrent::ScheduledTask
  def self.execute(delay, opts=T.unsafe(nil), &task); end
end

class Concurrent::Semaphore
end

class Concurrent::Semaphore
end

module Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def serialized?(); end
end

module Concurrent::SerialExecutorService
end

class Concurrent::SerializedExecution
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(); end

  def post(executor, *args, &task); end

  def posts(posts); end
end

class Concurrent::SerializedExecution::Job
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def call(); end

  def executor(); end

  def executor=(_); end
end

class Concurrent::SerializedExecution::Job
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::SerializedExecution
end

class Concurrent::SerializedExecutionDelegator
  include ::Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(executor); end
end

class Concurrent::SerializedExecutionDelegator
end

class Concurrent::Set
end

class Concurrent::Set
end

module Concurrent::SettableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::SettableStruct
  def self.new(*args, &block); end
end

class Concurrent::SimpleExecutorService
end

class Concurrent::SimpleExecutorService
  def self.<<(task); end

  def self.post(*args); end
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::SingleThreadExecutor
end

module Concurrent::Synchronization
end

class Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast(); end

  def ns_signal(); end

  def ns_wait(timeout=T.unsafe(nil)); end

  def ns_wait_until(timeout=T.unsafe(nil), &condition); end

  def synchronize(); end
end

class Concurrent::Synchronization::AbstractLockableObject
end

class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier(); end
end

class Concurrent::Synchronization::AbstractObject
  def self.attr_volatile(*names); end
end

module Concurrent::Synchronization::AbstractStruct
  def initialize(*values); end

  def length(); end

  def members(); end

  def ns_each(); end

  def ns_each_pair(); end

  def ns_equality(other); end

  def ns_get(member); end

  def ns_inspect(); end

  def ns_merge(other, &block); end

  def ns_select(); end

  def ns_to_h(); end

  def ns_values(); end

  def ns_values_at(indexes); end

  def pr_underscore(clazz); end

  def size(); end
end

module Concurrent::Synchronization::AbstractStruct
  def self.define_struct_class(parent, base, name, members, &block); end
end

class Concurrent::Synchronization::Condition
  def broadcast(); end

  def initialize(lock); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Condition
  def self.private_new(*args, &block); end
end

module Concurrent::Synchronization::ConditionSignalling
  def ns_broadcast(); end

  def ns_signal(); end
end

module Concurrent::Synchronization::ConditionSignalling
end

class Concurrent::Synchronization::Lock
  def broadcast(); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Lock
end

class Concurrent::Synchronization::LockableObject
  def new_condition(); end
end

class Concurrent::Synchronization::LockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MonitorLockableObject
  def self.new(*args, &block); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::MriObject
  include ::Concurrent::Synchronization::MriAttrVolatile
end

class Concurrent::Synchronization::MriObject
end

class Concurrent::Synchronization::MutexLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MutexLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::Object
end

class Concurrent::Synchronization::Object
  def self.atomic_attribute?(name); end

  def self.atomic_attributes(inherited=T.unsafe(nil)); end

  def self.attr_atomic(*names); end

  def self.ensure_safe_initialization_when_final_fields_are_present(); end

  def self.safe_initialization!(); end

  def self.safe_initialization?(); end
end

module Concurrent::Synchronization::RbxAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::RbxAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::RbxLockableObject
  def initialize(*defaults); end

  def synchronize(&block); end
end

class Concurrent::Synchronization::RbxLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::RbxObject
  include ::Concurrent::Synchronization::RbxAttrVolatile
end

class Concurrent::Synchronization::RbxObject
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::TruffleRubyObject
  include ::Concurrent::Synchronization::TruffleRubyAttrVolatile
end

class Concurrent::Synchronization::TruffleRubyObject
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::Synchronization
end

class Concurrent::SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class Concurrent::SynchronizedDelegator
end

class Concurrent::TVar
  def initialize(value); end

  def unsafe_increment_version(); end

  def unsafe_lock(); end

  def unsafe_value(); end

  def unsafe_value=(value); end

  def unsafe_version(); end

  def value(); end

  def value=(value); end
end

class Concurrent::TVar
  def self.new(*args, &block); end
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadPoolExecutor
end

class Concurrent::ThreadPoolExecutor
end

module Concurrent::ThreadSafe
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
end

module Concurrent::ThreadSafe
end

class Concurrent::TimeoutError
end

class Concurrent::TimeoutError
end

class Concurrent::TimerSet
  def initialize(opts=T.unsafe(nil)); end

  def post(delay, *args, &task); end
end

class Concurrent::TimerSet
end

class Concurrent::TimerTask
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def execute(); end

  def execution_interval(); end

  def execution_interval=(value); end

  def initialize(opts=T.unsafe(nil), &task); end

  def timeout_interval(); end

  def timeout_interval=(value); end
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  def self.execute(opts=T.unsafe(nil), &task); end
end

class Concurrent::Transaction
  def abort(); end

  def commit(); end

  def read(tvar); end

  def unlock(); end

  def valid?(); end

  def write(tvar, value); end
  ABORTED = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::ReadLogEntry
  def tvar(); end

  def tvar=(_); end

  def version(); end

  def version=(_); end
end

class Concurrent::Transaction::ReadLogEntry
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::Transaction
  def self.current(); end

  def self.current=(transaction); end
end

class Concurrent::Tuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def get(i); end

  def initialize(size); end

  def set(i, value); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class Concurrent::Tuple
end

module Concurrent::Utility
end

module Concurrent::Utility::EngineDetector
  def on_cruby?(); end

  def on_jruby?(); end

  def on_jruby_9000?(); end

  def on_linux?(); end

  def on_osx?(); end

  def on_rbx?(); end

  def on_truffleruby?(); end

  def on_windows?(); end

  def ruby_engine(); end

  def ruby_version(version=T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::EngineDetector
end

module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?(); end

  def c_extensions_loaded?(); end

  def java_extensions_loaded?(); end

  def load_native_extensions(); end
end

module Concurrent::Utility::NativeExtensionLoader
end

module Concurrent::Utility::NativeInteger
  def ensure_integer(value); end

  def ensure_integer_and_bounds(value); end

  def ensure_lower_bound(value); end

  def ensure_positive(value); end

  def ensure_positive_and_no_zero(value); end

  def ensure_upper_bound(value); end
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  extend ::Concurrent::Utility::NativeInteger
end

class Concurrent::Utility::ProcessorCounter
  def physical_processor_count(); end

  def processor_count(); end
end

class Concurrent::Utility::ProcessorCounter
end

module Concurrent::Utility
end

module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  def self.abort_transaction(); end

  def self.atomically(); end

  def self.call_dataflow(method, executor, *inputs, &block); end

  def self.create_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.create_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.dataflow(*inputs, &block); end

  def self.dataflow!(*inputs, &block); end

  def self.dataflow_with(executor, *inputs, &block); end

  def self.dataflow_with!(executor, *inputs, &block); end

  def self.disable_at_exit_handlers!(); end

  def self.executor(executor_identifier); end

  def self.global_fast_executor(); end

  def self.global_immediate_executor(); end

  def self.global_io_executor(); end

  def self.global_logger(); end

  def self.global_logger=(value); end

  def self.global_timer_set(); end

  def self.leave_transaction(); end

  def self.monotonic_time(); end

  def self.new_fast_executor(opts=T.unsafe(nil)); end

  def self.new_io_executor(opts=T.unsafe(nil)); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.processor_counter(); end

  def self.use_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.use_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

EM = EventMachine

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

module EventMachine
  ConnectionAccepted = ::T.let(nil, ::T.untyped)
  ConnectionCompleted = ::T.let(nil, ::T.untyped)
  ConnectionData = ::T.let(nil, ::T.untyped)
  ConnectionNotifyReadable = ::T.let(nil, ::T.untyped)
  ConnectionNotifyWritable = ::T.let(nil, ::T.untyped)
  ConnectionUnbound = ::T.let(nil, ::T.untyped)
  EM_PROTO_SSLv2 = ::T.let(nil, ::T.untyped)
  EM_PROTO_SSLv3 = ::T.let(nil, ::T.untyped)
  EM_PROTO_TLSv1 = ::T.let(nil, ::T.untyped)
  EM_PROTO_TLSv1_1 = ::T.let(nil, ::T.untyped)
  EM_PROTO_TLSv1_2 = ::T.let(nil, ::T.untyped)
  ERRNOS = ::T.let(nil, ::T.untyped)
  LoopbreakSignalled = ::T.let(nil, ::T.untyped)
  SslHandshakeCompleted = ::T.let(nil, ::T.untyped)
  SslVerify = ::T.let(nil, ::T.untyped)
  TimerFired = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class EventMachine::Channel
  def <<(*items); end

  def num_subscribers(); end

  def pop(*a, &b); end

  def push(*items); end

  def subscribe(*a, &b); end

  def unsubscribe(name); end
end

class EventMachine::Channel
end

class EventMachine::Completion
  include ::EventMachine::Deferrable
  def callback(*a, &b); end

  def cancel_callback(*a, &b); end

  def cancel_errback(*a, &b); end

  def change_state(state, *args); end

  def completed?(); end

  def completion(*a, &b); end

  def completion_states(); end

  def errback(*a, &b); end

  def set_deferred_status(state, *args); end

  def state(); end

  def stateback(state, *a, &b); end

  def timeout(time, *args); end

  def value(); end
end

class EventMachine::Completion
end

class EventMachine::Connection
  def associate_callback_target(_); end

  def close_connection(after_writing=T.unsafe(nil)); end

  def close_connection_after_writing(); end

  def comm_inactivity_timeout(); end

  def comm_inactivity_timeout=(value); end

  def connection_completed(); end

  def detach(); end

  def error?(); end

  def get_cipher_bits(); end

  def get_cipher_name(); end

  def get_cipher_protocol(); end

  def get_idle_time(); end

  def get_outbound_data_size(); end

  def get_peer_cert(); end

  def get_peername(); end

  def get_pid(); end

  def get_proxied_bytes(); end

  def get_sni_hostname(); end

  def get_sock_opt(level, option); end

  def get_sockname(); end

  def get_status(); end

  def initialize(*args); end

  def notify_readable=(mode); end

  def notify_readable?(); end

  def notify_writable=(mode); end

  def notify_writable?(); end

  def original_method(_); end

  def pause(); end

  def paused?(); end

  def pending_connect_timeout(); end

  def pending_connect_timeout=(value); end

  def post_init(); end

  def proxy_completed(); end

  def proxy_incoming_to(conn, bufsize=T.unsafe(nil)); end

  def proxy_target_unbound(); end

  def receive_data(data); end

  def reconnect(server, port); end

  def resume(); end

  def send_data(data); end

  def send_datagram(data, recipient_address, recipient_port); end

  def send_file_data(filename); end

  def set_comm_inactivity_timeout(value); end

  def set_pending_connect_timeout(value); end

  def set_sock_opt(level, optname, optval); end

  def signature(); end

  def signature=(signature); end

  def ssl_handshake_completed(); end

  def ssl_verify_peer(cert); end

  def start_tls(args=T.unsafe(nil)); end

  def stop_proxying(); end

  def stream_file_data(filename, args=T.unsafe(nil)); end

  def unbind(); end
end

class EventMachine::Connection
  def self.new(sig, *args); end
end

class EventMachine::ConnectionError
end

class EventMachine::ConnectionError
end

class EventMachine::ConnectionNotBound
end

class EventMachine::ConnectionNotBound
end

module EventMachine::DNS
end

class EventMachine::DNS::Request
  include ::EventMachine::Deferrable
  def initialize(socket, hostname); end

  def max_tries(); end

  def max_tries=(max_tries); end

  def receive_answer(msg); end

  def retry_interval(); end

  def retry_interval=(retry_interval); end

  def tick(); end
end

class EventMachine::DNS::Request
end

class EventMachine::DNS::RequestIdAlreadyUsed
end

class EventMachine::DNS::RequestIdAlreadyUsed
end

class EventMachine::DNS::Resolver
  HOSTS_FILE = ::T.let(nil, ::T.untyped)
end

class EventMachine::DNS::Resolver
  def self.hosts(); end

  def self.nameserver(); end

  def self.nameservers(); end

  def self.nameservers=(ns); end

  def self.resolve(hostname); end

  def self.socket(); end

  def self.windows?(); end
end

class EventMachine::DNS::Socket
  def deregister_request(id, req); end

  def initialize(); end

  def nameserver(); end

  def nameserver=(ns); end

  def register_request(id, req); end

  def send_packet(pkt); end

  def start_timer(); end

  def stop_timer(); end

  def tick(); end
end

class EventMachine::DNS::Socket
  def self.open(); end
end

module EventMachine::DNS
end

class EventMachine::DefaultDeferrable
  include ::EventMachine::Deferrable
end

class EventMachine::DefaultDeferrable
end

module EventMachine::Deferrable
  def callback(&block); end

  def cancel_callback(block); end

  def cancel_errback(block); end

  def cancel_timeout(); end

  def errback(&block); end

  def fail(*args); end

  def set_deferred_failure(*args); end

  def set_deferred_status(status, *args); end

  def set_deferred_success(*args); end

  def succeed(*args); end

  def timeout(seconds, *args); end
end

EventMachine::Deferrable::Pool = EventMachine::Pool

module EventMachine::Deferrable
  def self.future(arg, cb=T.unsafe(nil), eb=T.unsafe(nil), &blk); end
end

class EventMachine::DeferrableChildProcess
  include ::EventMachine::Deferrable
  def initialize(); end
end

class EventMachine::DeferrableChildProcess
  def self.open(cmd); end
end

class EventMachine::FileNotFoundException
end

class EventMachine::FileNotFoundException
end

class EventMachine::FileStreamer
  include ::EventMachine::Deferrable
  def initialize(connection, filename, args=T.unsafe(nil)); end

  def stream_one_chunk(); end
  BackpressureLevel = ::T.let(nil, ::T.untyped)
  ChunkSize = ::T.let(nil, ::T.untyped)
  MappingThreshold = ::T.let(nil, ::T.untyped)
end

class EventMachine::FileStreamer
end

class EventMachine::FileWatch
  def file_deleted(); end

  def file_modified(); end

  def file_moved(); end

  def path(); end

  def stop_watching(); end
  Cdeleted = ::T.let(nil, ::T.untyped)
  Cmodified = ::T.let(nil, ::T.untyped)
  Cmoved = ::T.let(nil, ::T.untyped)
end

class EventMachine::FileWatch
end

class EventMachine::InvalidSignature
end

class EventMachine::InvalidSignature
end

class EventMachine::Iterator
  def concurrency(); end

  def concurrency=(val); end

  def each(foreach=T.unsafe(nil), after=T.unsafe(nil), &blk); end

  def initialize(list, concurrency=T.unsafe(nil)); end

  def inject(obj, foreach, after); end

  def map(foreach, after); end
  Stop = ::T.let(nil, ::T.untyped)
end

class EventMachine::Iterator
end

class EventMachine::NoHandlerForAcceptedConnection
end

class EventMachine::NoHandlerForAcceptedConnection
end

EventMachine::P = EventMachine::Protocols

class EventMachine::PeriodicTimer
  def cancel(); end

  def fire(); end

  def initialize(interval, callback=T.unsafe(nil), &block); end

  def interval(); end

  def interval=(interval); end

  def schedule(); end
end

class EventMachine::PeriodicTimer
end

class EventMachine::Pool
  def add(resource); end

  def completion(deferrable, resource); end

  def contents(); end

  def failure(resource); end

  def num_waiting(); end

  def on_error(*a, &b); end

  def perform(*a, &b); end

  def process(work, resource); end

  def remove(resource); end

  def removed?(resource); end

  def requeue(resource); end

  def reschedule(*a, &b); end
end

class EventMachine::Pool
end

class EventMachine::ProcessWatch
  def pid(); end

  def process_exited(); end

  def process_forked(); end

  def stop_watching(); end
  Cexit = ::T.let(nil, ::T.untyped)
  Cfork = ::T.let(nil, ::T.untyped)
end

class EventMachine::ProcessWatch
end

module EventMachine::Protocols
end

class EventMachine::Protocols::HeaderAndContentProtocol
  include ::EventMachine::Protocols::LineText2
  def headers_2_hash(hdrs); end

  def receive_binary_data(text); end

  def receive_line(line); end
  ContentLengthPattern = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::HeaderAndContentProtocol
  def self.headers_2_hash(hdrs); end
end

class EventMachine::Protocols::HttpClient
  include ::EventMachine::Deferrable
  def dispatch_response(); end

  def initialize(); end

  def send_request(args); end
  MaxPostContentLength = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::HttpClient
  def self.request(args=T.unsafe(nil)); end
end

class EventMachine::Protocols::HttpClient2
  include ::EventMachine::Protocols::LineText2
  def get(args); end

  def initialize(); end

  def pop_request(); end

  def post(args); end

  def receive_binary_data(text); end

  def request(args); end

  def set_default_host_header(host, port, ssl); end
end

class EventMachine::Protocols::HttpClient2::Request
  include ::EventMachine::Deferrable
  def content(); end

  def header_lines(); end

  def headers(); end

  def initialize(conn, args); end

  def internal_error(); end

  def receive_chunk_header(ln); end

  def receive_chunk_trailer(ln); end

  def receive_chunked_text(text); end

  def receive_header_line(ln); end

  def receive_line(ln); end

  def receive_sized_text(text); end

  def receive_text(text); end

  def send_request(); end

  def status(); end

  def version(); end
  ChunkedRE = ::T.let(nil, ::T.untyped)
  ClenRE = ::T.let(nil, ::T.untyped)
  ColonRE = ::T.let(nil, ::T.untyped)
  HttpResponseRE = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::HttpClient2::Request
end

class EventMachine::Protocols::HttpClient2
  def self.connect(*args); end
end

class EventMachine::Protocols::LineAndTextProtocol
  def set_binary_mode(size=T.unsafe(nil)); end
  MaxBinaryLength = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::LineAndTextProtocol
end

module EventMachine::Protocols::LineProtocol
  def receive_data(data); end

  def receive_line(line); end
end

module EventMachine::Protocols::LineProtocol
end

module EventMachine::Protocols::LineText2
  def receive_binary_data(data); end

  def receive_data(data); end

  def receive_end_of_binary_data(); end

  def receive_line(ln); end

  def set_binary_mode(size=T.unsafe(nil)); end

  def set_delimiter(delim); end

  def set_line_mode(data=T.unsafe(nil)); end

  def set_text_mode(size=T.unsafe(nil)); end

  def unbind(); end
  MaxBinaryLength = ::T.let(nil, ::T.untyped)
end

module EventMachine::Protocols::LineText2
end

module EventMachine::Protocols::Memcache
  include ::EventMachine::Deferrable
  def connection_completed(); end

  def del(key, expires=T.unsafe(nil), &cb); end

  def delete(key, expires=T.unsafe(nil), &cb); end

  def get(*keys); end

  def get_hash(*keys); end

  def initialize(host, port=T.unsafe(nil)); end

  def process_cmd(line); end

  def receive_data(data); end

  def set(key, val, exptime=T.unsafe(nil), &cb); end

  def unbind(); end
  Cdeleted = ::T.let(nil, ::T.untyped)
  Cdelimiter = ::T.let(nil, ::T.untyped)
  Cempty = ::T.let(nil, ::T.untyped)
  Cend = ::T.let(nil, ::T.untyped)
  Cerror = ::T.let(nil, ::T.untyped)
  Cstored = ::T.let(nil, ::T.untyped)
  Cunknown = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::Memcache::ParserError
end

class EventMachine::Protocols::Memcache::ParserError
end

module EventMachine::Protocols::Memcache
  def self.connect(host=T.unsafe(nil), port=T.unsafe(nil)); end
end

module EventMachine::Protocols::ObjectProtocol
  def receive_data(data); end

  def receive_object(obj); end

  def send_object(obj); end

  def serializer(); end
end

module EventMachine::Protocols::ObjectProtocol
end

module EventMachine::Protocols::SASLauth
  def post_init(); end

  def receive_data(data); end

  def validate(username, psw, sysname, realm); end
  MaxFieldSize = ::T.let(nil, ::T.untyped)
end

module EventMachine::Protocols::SASLauth
end

class EventMachine::Protocols::SmtpClient
  include ::EventMachine::Deferrable
  include ::EventMachine::Protocols::LineText2
  def args=(args); end

  def initialize(); end
end

class EventMachine::Protocols::SmtpClient
  def self.send(args=T.unsafe(nil)); end
end

class EventMachine::Protocols::SmtpServer
  include ::EventMachine::Protocols::LineText2
  def connection_ended(); end

  def get_server_domain(); end

  def get_server_greeting(); end

  def init_protocol_state(); end

  def parms=(parms=T.unsafe(nil)); end

  def process_auth(str); end

  def process_auth_line(line); end

  def process_data(); end

  def process_data_line(ln); end

  def process_ehlo(domain); end

  def process_expn(); end

  def process_helo(domain); end

  def process_help(); end

  def process_mail_from(sender); end

  def process_noop(); end

  def process_quit(); end

  def process_rcpt_to(rcpt); end

  def process_rset(); end

  def process_starttls(); end

  def process_unknown(); end

  def process_vrfy(); end

  def receive_data_chunk(data); end

  def receive_data_command(); end

  def receive_ehlo_domain(domain); end

  def receive_message(); end

  def receive_plain_auth(user, password); end

  def receive_recipient(rcpt); end

  def receive_reset(); end

  def receive_sender(sender); end

  def receive_transaction(); end

  def reset_protocol_state(); end

  def send_server_greeting(); end
  AuthRegex = ::T.let(nil, ::T.untyped)
  DataRegex = ::T.let(nil, ::T.untyped)
  EhloRegex = ::T.let(nil, ::T.untyped)
  ExpnRegex = ::T.let(nil, ::T.untyped)
  HeloRegex = ::T.let(nil, ::T.untyped)
  HelpRegex = ::T.let(nil, ::T.untyped)
  MailFromRegex = ::T.let(nil, ::T.untyped)
  NoopRegex = ::T.let(nil, ::T.untyped)
  QuitRegex = ::T.let(nil, ::T.untyped)
  RcptToRegex = ::T.let(nil, ::T.untyped)
  RsetRegex = ::T.let(nil, ::T.untyped)
  StarttlsRegex = ::T.let(nil, ::T.untyped)
  VrfyRegex = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::SmtpServer
  def self.parms=(parms=T.unsafe(nil)); end
end

class EventMachine::Protocols::Socks4
  def initialize(host, port); end

  def restore_methods(); end

  def setup_methods(); end

  def socks_post_init(); end

  def socks_receive_data(data); end
end

class EventMachine::Protocols::Socks4
end

module EventMachine::Protocols::Stomp
  include ::EventMachine::Protocols::LineText2
  def ack(msgid); end

  def connect(parms=T.unsafe(nil)); end

  def init_message_reader(); end

  def receive_binary_data(data); end

  def receive_line(line); end

  def receive_msg(msg); end

  def send(destination, body, parms=T.unsafe(nil)); end

  def send_frame(verb, headers=T.unsafe(nil), body=T.unsafe(nil)); end

  def subscribe(dest, ack=T.unsafe(nil)); end
end

class EventMachine::Protocols::Stomp::Message
  def body(); end

  def body=(body); end

  def command(); end

  def command=(command); end

  def consume_line(line); end

  def header(); end

  def header=(header); end

  def headers(); end
end

class EventMachine::Protocols::Stomp::Message
end

module EventMachine::Protocols::Stomp
end

class EventMachine::Protocols::TcpConnectTester
  include ::EventMachine::Deferrable
end

class EventMachine::Protocols::TcpConnectTester
  def self.test(host, port); end
end

module EventMachine::Protocols
end

class EventMachine::Queue
  def <<(*items); end

  def empty?(); end

  def num_waiting(); end

  def pop(*a, &b); end

  def push(*items); end

  def size(); end
end

class EventMachine::Queue
end

class EventMachine::SpawnedProcess
  def notify(*x); end

  def resume(*x); end

  def run(*x); end

  def set_receiver(blk); end
end

class EventMachine::SpawnedProcess
end

class EventMachine::SystemCmd
  def initialize(cb); end
end

class EventMachine::SystemCmd
end

class EventMachine::ThreadedResource
  def dispatch(); end

  def shutdown(); end
end

class EventMachine::ThreadedResource
end

class EventMachine::TickLoop
  def initialize(*a, &b); end

  def on_stop(*a, &b); end

  def start(); end

  def stop(); end

  def stopped?(); end
end

class EventMachine::TickLoop
end

class EventMachine::Timer
  def cancel(); end

  def initialize(interval, callback=T.unsafe(nil), &block); end
end

class EventMachine::Timer
end

class EventMachine::UnknownTimerFired
end

class EventMachine::UnknownTimerFired
end

class EventMachine::Unsupported
end

class EventMachine::Unsupported
end

class EventMachine::YieldBlockFromSpawnedProcess
  def initialize(block, notify); end

  def pull_out_yield_block(); end
end

class EventMachine::YieldBlockFromSpawnedProcess
end

module EventMachine
  def self.Callback(object=T.unsafe(nil), method=T.unsafe(nil), &blk); end

  def self._open_file_for_writing(filename, handler=T.unsafe(nil)); end

  def self.add_oneshot_timer(_); end

  def self.add_periodic_timer(*args, &block); end

  def self.add_shutdown_hook(&block); end

  def self.add_timer(*args, &block); end

  def self.attach(io, handler=T.unsafe(nil), *args, &blk); end

  def self.attach_fd(_, _1); end

  def self.attach_io(io, watch_mode, handler=T.unsafe(nil), *args); end

  def self.attach_sd(_); end

  def self.attach_server(sock, handler=T.unsafe(nil), *args, &block); end

  def self.bind_connect(bind_addr, bind_port, server, port=T.unsafe(nil), handler=T.unsafe(nil), *args); end

  def self.bind_connect_server(_, _1, _2, _3); end

  def self.cancel_timer(timer_or_sig); end

  def self.cleanup_machine(); end

  def self.close_connection(_, _1); end

  def self.connect(server, port=T.unsafe(nil), handler=T.unsafe(nil), *args, &blk); end

  def self.connect_server(_, _1); end

  def self.connect_unix_domain(socketname, *args, &blk); end

  def self.connect_unix_server(_); end

  def self.connection_count(); end

  def self.connection_paused?(_); end

  def self.current_time(); end

  def self.defer(op=T.unsafe(nil), callback=T.unsafe(nil), errback=T.unsafe(nil), &blk); end

  def self.defers_finished?(); end

  def self.detach_fd(_); end

  def self.disable_proxy(from); end

  def self.enable_proxy(from, to, bufsize=T.unsafe(nil), length=T.unsafe(nil)); end

  def self.epoll(); end

  def self.epoll=(epoll); end

  def self.epoll?(); end

  def self.error_handler(cb=T.unsafe(nil), &blk); end

  def self.event_callback(conn_binding, opcode, data); end

  def self.fork_reactor(&block); end

  def self.get_cipher_bits(_); end

  def self.get_cipher_name(_); end

  def self.get_cipher_protocol(_); end

  def self.get_comm_inactivity_timeout(_); end

  def self.get_connection_count(); end

  def self.get_file_descriptor(_); end

  def self.get_heartbeat_interval(); end

  def self.get_idle_time(_); end

  def self.get_max_timer_count(); end

  def self.get_max_timers(); end

  def self.get_peer_cert(_); end

  def self.get_peername(_); end

  def self.get_pending_connect_timeout(_); end

  def self.get_proxied_bytes(_); end

  def self.get_simultaneous_accept_count(); end

  def self.get_sni_hostname(_); end

  def self.get_sock_opt(_, _1, _2); end

  def self.get_sockname(_); end

  def self.get_subprocess_pid(_); end

  def self.get_subprocess_status(_); end

  def self.heartbeat_interval(); end

  def self.heartbeat_interval=(time); end

  def self.initialize_event_machine(); end

  def self.invoke_popen(_); end

  def self.is_notify_readable(_); end

  def self.is_notify_writable(_); end

  def self.klass_from_handler(klass=T.unsafe(nil), handler=T.unsafe(nil), *args); end

  def self.kqueue(); end

  def self.kqueue=(kqueue); end

  def self.kqueue?(); end

  def self.library_type(); end

  def self.next_tick(pr=T.unsafe(nil), &block); end

  def self.num_close_scheduled(); end

  def self.open_datagram_socket(address, port, handler=T.unsafe(nil), *args); end

  def self.open_keyboard(handler=T.unsafe(nil), *args); end

  def self.open_udp_socket(_, _1); end

  def self.pause_connection(_); end

  def self.popen(cmd, handler=T.unsafe(nil), *args); end

  def self.reactor_running?(); end

  def self.reactor_thread(); end

  def self.reactor_thread?(); end

  def self.read_keyboard(); end

  def self.reconnect(server, port, handler); end

  def self.release_machine(); end

  def self.report_connection_error_status(_); end

  def self.resume_connection(_); end

  def self.run(blk=T.unsafe(nil), tail=T.unsafe(nil), &block); end

  def self.run_block(&block); end

  def self.run_deferred_callbacks(); end

  def self.run_machine(); end

  def self.run_machine_once(); end

  def self.run_machine_without_threads(); end

  def self.schedule(*a, &b); end

  def self.send_data(_, _1, _2); end

  def self.send_datagram(_, _1, _2, _3, _4); end

  def self.send_file_data(_, _1); end

  def self.set_comm_inactivity_timeout(_, _1); end

  def self.set_descriptor_table_size(n_descriptors=T.unsafe(nil)); end

  def self.set_effective_user(username); end

  def self.set_heartbeat_interval(_); end

  def self.set_max_timer_count(_); end

  def self.set_max_timers(ct); end

  def self.set_notify_readable(_, _1); end

  def self.set_notify_writable(_, _1); end

  def self.set_pending_connect_timeout(_, _1); end

  def self.set_quantum(mills); end

  def self.set_rlimit_nofile(_); end

  def self.set_simultaneous_accept_count(_); end

  def self.set_sock_opt(_, _1, _2, _3); end

  def self.set_timer_quantum(_); end

  def self.set_tls_parms(_, _1, _2, _3, _4, _5, _6, _7, _8, _9); end

  def self.setuid_string(_); end

  def self.signal_loopbreak(); end

  def self.spawn(&block); end

  def self.spawn_threadpool(); end

  def self.ssl?(); end

  def self.start_proxy(_, _1, _2, _3); end

  def self.start_server(server, port=T.unsafe(nil), handler=T.unsafe(nil), *args, &block); end

  def self.start_tcp_server(_, _1); end

  def self.start_tls(_); end

  def self.start_unix_domain_server(filename, *args, &block); end

  def self.start_unix_server(_); end

  def self.stop(); end

  def self.stop_event_loop(); end

  def self.stop_proxy(_); end

  def self.stop_server(signature); end

  def self.stop_tcp_server(_); end

  def self.stopping?(); end

  def self.system(cmd, *args, &cb); end

  def self.threadpool(); end

  def self.threadpool_size(); end

  def self.threadpool_size=(threadpool_size); end

  def self.tick_loop(*a, &b); end

  def self.unwatch_filename(_); end

  def self.unwatch_pid(_); end

  def self.watch(io, handler=T.unsafe(nil), *args, &blk); end

  def self.watch_file(filename, handler=T.unsafe(nil), *args); end

  def self.watch_filename(_); end

  def self.watch_pid(_); end

  def self.watch_process(pid, handler=T.unsafe(nil), *args); end

  def self.yield(&block); end

  def self.yield_and_notify(&block); end
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  def flock?(); end

  def flock_sh(); end
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, &block); end

  def safe_ln(*args); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.concat(src, dest); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

class Gem::Package::TarHeader
  def self.oct_or_256based(str); end
end

class Gem::RemoteFetcher
  def s3_uri_signer(uri); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::S3URISigner
  def initialize(uri); end

  def sign(expiration=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
  EC2_METADATA_CREDENTIALS = ::T.let(nil, ::T.untyped)
end

class Gem::S3URISigner::ConfigurationError
  def initialize(message); end
end

class Gem::S3URISigner::ConfigurationError
end

class Gem::S3URISigner::InstanceProfileError
  def initialize(message); end
end

class Gem::S3URISigner::InstanceProfileError
end

class Gem::S3URISigner::S3Config
  def access_key_id(); end

  def access_key_id=(_); end

  def region(); end

  def region=(_); end

  def secret_access_key(); end

  def secret_access_key=(_); end

  def security_token(); end

  def security_token=(_); end
end

class Gem::S3URISigner::S3Config
  def self.[](*_); end

  def self.members(); end
end

class Gem::S3URISigner
end

class Gem::Specification
  extend ::Enumerable
end

module Gem::Util
  def self.correct_for_windows_path(path); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(*_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def external_encoding(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def pread(*_); end

  def pwrite(_, _1); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

module Kernel
  def LittlePlugger(opts=T.unsafe(nil)); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

module LittlePlugger
  VERSION = ::T.let(nil, ::T.untyped)
end

module LittlePlugger::ClassMethods
  def disregard_plugin(*names); end

  def disregard_plugins(*names); end

  def initialize_plugins(); end

  def load_plugins(); end

  def plugin(*names); end

  def plugin_module(); end

  def plugin_names(); end

  def plugin_path(); end

  def plugins(); end
end

module LittlePlugger::ClassMethods
end

module LittlePlugger
  def self.default_plugin_module(path); end

  def self.default_plugin_path(obj); end

  def self.extended(other); end

  def self.underscore(string); end

  def self.version(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Logging
  DEFAULT_CAUSE_DEPTH = ::T.let(nil, ::T.untyped)
  DIAGNOSTIC_MUTEX = ::T.let(nil, ::T.untyped)
  INHERIT_CONTEXT = ::T.let(nil, ::T.untyped)
  LEVELS = ::T.let(nil, ::T.untyped)
  LIBPATH = ::T.let(nil, ::T.untyped)
  LNAMES = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Logging::Appender
  def <<(str); end

  def _to_s(); end

  def add_filters(*args); end

  def allow(event); end

  def append(event); end

  def close(footer=T.unsafe(nil)); end

  def closed?(); end

  def encoding(); end

  def encoding=(value); end

  def filters(); end

  def filters=(args); end

  def flush(); end

  def initialize(name, opts=T.unsafe(nil)); end

  def layout(); end

  def layout=(layout); end

  def level(); end

  def level=(level); end

  def name(); end

  def off?(); end

  def reopen(); end
end

class Logging::Appender
end

module Logging::Appenders
  def [](name); end

  def []=(name, value); end

  def each(&block); end

  def remove(name); end

  def reset(); end
end

module Logging::Appenders::Buffering
  def async(); end

  def async=(bool); end

  def async?(); end

  def auto_flushing(); end

  def auto_flushing=(period); end

  def buffer(); end

  def clear!(); end

  def close(*args); end

  def configure_buffering(opts); end

  def flush(); end

  def flush_period(); end

  def flush_period=(period); end

  def flush_period?(); end

  def immediate?(event); end

  def immediate_at=(level); end

  def initialize(*args, &block); end

  def reopen(); end

  def write_size(); end

  def write_size=(write_size); end
  DEFAULT_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
end

class Logging::Appenders::Buffering::AsyncFlusher
  def immediate?(); end

  def initialize(appender, period); end

  def signal(immediate=T.unsafe(nil)); end

  def start(); end

  def stop(); end

  def waiting?(); end
end

class Logging::Appenders::Buffering::AsyncFlusher
end

module Logging::Appenders::Buffering
end

class Logging::Appenders::Console
  def initialize(*args); end
end

class Logging::Appenders::Console
end

class Logging::Appenders::File
  def filename(); end

  def initialize(name, opts=T.unsafe(nil)); end
end

class Logging::Appenders::File
  def self.assert_valid_logfile(fn); end
end

class Logging::Appenders::IO
  include ::Logging::Appenders::Buffering
  def close_method(); end

  def close_method=(close_method); end

  def initialize(name, io, opts=T.unsafe(nil)); end
end

class Logging::Appenders::IO
end

class Logging::Appenders::RollingFile
  def filename(); end

  def initialize(name, opts=T.unsafe(nil)); end
end

class Logging::Appenders::RollingFile::Roller
  def copy_file(); end

  def filename(); end

  def format(); end

  def glob(); end

  def initialize(name, opts); end

  def keep(); end

  def roll(); end

  def roll=(roll); end

  def roll_by(); end

  def roll_by_date(files); end

  def roll_by_number(files); end

  def roll_files(); end
  RGXP = ::T.let(nil, ::T.untyped)
end

class Logging::Appenders::RollingFile::Roller
end

class Logging::Appenders::RollingFile
end

class Logging::Appenders::Stderr
end

class Logging::Appenders::Stderr
end

class Logging::Appenders::Stdout
end

class Logging::Appenders::Stdout
end

class Logging::Appenders::StringIo
  def clear(); end

  def initialize(name, opts=T.unsafe(nil)); end

  def read(*args); end

  def readline(*args); end

  def readlines(*args); end

  def reset(); end

  def sio(); end
end

module Logging::Appenders::StringIo::IoToS
  def to_s(); end
end

module Logging::Appenders::StringIo::IoToS
end

class Logging::Appenders::StringIo
end

class Logging::Appenders::Syslog
  include ::Syslog::Constants
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
  def map=(levels); end
end

class Logging::Appenders::Syslog
  extend ::Syslog::Macros
end

module Logging::Appenders
  extend ::Logging::Appenders
  def self.file(*args); end

  def self.io(*args); end

  def self.rolling_file(*args); end

  def self.stderr(*args); end

  def self.stdout(*args); end

  def self.string_io(*args); end

  def self.syslog(*args); end
end

class Logging::ColorScheme
  def [](color_tag); end

  def []=(color_tag, constants); end

  def color(string, *colors); end

  def include?(color_tag); end

  def initialize(name, opts=T.unsafe(nil)); end

  def levels?(); end

  def lines?(); end

  def load_from_hash(h); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLINK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  BRIGHT_BLUE = ::T.let(nil, ::T.untyped)
  BRIGHT_CYAN = ::T.let(nil, ::T.untyped)
  BRIGHT_GREEN = ::T.let(nil, ::T.untyped)
  BRIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  BRIGHT_RED = ::T.let(nil, ::T.untyped)
  BRIGHT_WHITE = ::T.let(nil, ::T.untyped)
  BRIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CONCEALED = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  DARK = ::T.let(nil, ::T.untyped)
  ERASE_CHAR = ::T.let(nil, ::T.untyped)
  ERASE_LINE = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLUE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_CYAN = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREEN = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_RED = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_WHITE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Logging::ColorScheme
  def self.[](name); end

  def self.[]=(name, value); end

  def self.reset(); end
end

class Logging::Filter
  def allow(event); end
end

class Logging::Filter
end

module Logging::Filters
end

class Logging::Filters::Level
  def initialize(*levels); end
end

class Logging::Filters::Level
end

module Logging::Filters
end

class Logging::Layout
  def apply_utc_offset(time); end

  def backtrace(); end

  def backtrace=(value); end

  def backtrace?(); end

  def cause_depth(); end

  def cause_depth=(value); end

  def footer(); end

  def format(event); end

  def format_cause(e, lines); end

  def format_cause_backtrace(e, cause); end

  def format_obj(obj); end

  def header(); end

  def initialize(opts=T.unsafe(nil)); end

  def try_json(obj); end

  def try_yaml(obj); end

  def utc_offset(); end

  def utc_offset=(value); end
end

class Logging::Layout
end

module Logging::Layouts
end

class Logging::Layouts::Basic
end

class Logging::Layouts::Basic
end

class Logging::Layouts::Parseable
  def format_cause(e); end

  def items(); end

  def items=(ary); end
  DIRECTIVE_TABLE = ::T.let(nil, ::T.untyped)
end

class Logging::Layouts::Parseable
  def self.create_json_format_method(layout); end

  def self.create_yaml_format_method(layout); end

  def self.json(opts=T.unsafe(nil)); end

  def self.yaml(opts=T.unsafe(nil)); end
end

class Logging::Layouts::Pattern
  def _meta_eval(code, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def color_scheme(); end

  def date_method(); end

  def date_method=(var); end

  def date_pattern(); end

  def date_pattern=(var); end

  def pattern(); end

  def pattern=(var); end
  ISO8601 = ::T.let(nil, ::T.untyped)
end

class Logging::Layouts::Pattern::FormatMethodBuilder
  def build_code(); end

  def build_format_string(); end

  def color_scheme(); end

  def colorize?(); end

  def colorize_levels?(); end

  def colorize_lines?(); end

  def format_string(); end

  def handle_directives(format, directive, precision); end

  def handle_level(format, directive, precision); end

  def handle_logger(format, directive, slice); end

  def handle_mdc(format, directive, key); end

  def handle_ndc(format, directive, separator); end

  def initialize(pattern_layout); end

  def layout(); end

  def name_map_count(); end

  def name_map_count=(name_map_count); end

  def pattern(); end

  def pattern=(pattern); end

  def sprintf_args(); end
  COLOR_ALIAS_TABLE = ::T.let(nil, ::T.untyped)
  DIRECTIVE_RGXP = ::T.let(nil, ::T.untyped)
  DIRECTIVE_TABLE = ::T.let(nil, ::T.untyped)
end

class Logging::Layouts::Pattern::FormatMethodBuilder
end

class Logging::Layouts::Pattern
  def self.create_date_format_methods(pl); end

  def self.create_format_method(pl); end
end

module Logging::Layouts
  def self.basic(*args); end

  def self.json(*args); end

  def self.parseable(); end

  def self.pattern(*args); end

  def self.yaml(*args); end
end

class Logging::LogEvent
  def data(); end

  def data=(data); end

  def file(); end

  def file=(file); end

  def initialize(logger, level, data, caller_tracing); end

  def level(); end

  def level=(level); end

  def line(); end

  def line=(line); end

  def logger(); end

  def logger=(logger); end

  def method(); end

  def method=(method); end

  def time(); end

  def time=(time); end
  CALLER_INDEX = ::T.let(nil, ::T.untyped)
  CALLER_RGXP = ::T.let(nil, ::T.untyped)
end

class Logging::LogEvent
end

class Logging::Logger
  include ::Logging::RailsCompat
  def <<(msg); end

  def _dump_configuration(indent=T.unsafe(nil)); end

  def _meta_eval(code, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def _setup(name, opts=T.unsafe(nil)); end

  def add(lvl, data=T.unsafe(nil), progname=T.unsafe(nil)); end

  def add_appenders(*args); end

  def additive(); end

  def additive=(val); end

  def appenders(); end

  def appenders=(args); end

  def caller_tracing(); end

  def caller_tracing=(val); end

  def clear_appenders(); end

  def define_log_methods(force=T.unsafe(nil), code=T.unsafe(nil)); end

  def has_own_level?(); end

  def initialize(name); end

  def level(); end

  def level=(level); end

  def log_event(event); end

  def name(); end

  def parent(); end

  def parent=(parent); end

  def remove_appenders(*args); end

  def write(msg); end
end

class Logging::Logger
  def self.[](name); end

  def self._reentrant_mutex(); end

  def self.define_log_methods(logger); end

  def self.instantiate(*_); end

  def self.log_methods_for_level(level); end

  def self.new(*args); end

  def self.root(); end
end

module Logging::MappedDiagnosticContext
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def clear_context(); end

  def context(); end

  def delete(key); end

  def flatten(ary); end

  def inherit(obj); end

  def peek(); end

  def pop(); end

  def push(hash); end

  def sanitize(hash, target=T.unsafe(nil)); end

  def stack(); end

  def update(hash); end
  NAME = ::T.let(nil, ::T.untyped)
  STACK_NAME = ::T.let(nil, ::T.untyped)
end

module Logging::MappedDiagnosticContext
  extend ::Logging::MappedDiagnosticContext
end

module Logging::NestedDiagnosticContext
  def <<(message); end

  def clear(); end

  def context(); end

  def inherit(obj); end

  def peek(); end

  def pop(); end

  def push(message); end
  NAME = ::T.let(nil, ::T.untyped)
end

module Logging::NestedDiagnosticContext
  extend ::Logging::NestedDiagnosticContext
end

module Logging::Plugins
end

module Logging::Plugins
end

class Logging::Proxy
  def initialize(object, &block); end

  def method_missing(name, *args, &block); end
  KEEPERS = ::T.let(nil, ::T.untyped)
end

class Logging::Proxy
end

module Logging::RailsCompat
  def formatter(); end

  def silence(*args); end
end

module Logging::RailsCompat
end

class Logging::Repository
  include ::Singleton
  def [](key); end

  def []=(key, val); end

  def children(parent); end

  def delete(key); end

  def fetch(key); end

  def has_logger?(key); end

  def parent(key); end

  def parent_name(key); end

  def to_key(key); end
  PATH_DELIMITER = ::T.let(nil, ::T.untyped)
end

class Logging::Repository
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end

  def self.reset(); end
end

class Logging::RootLogger
  def initialize(); end
end

class Logging::RootLogger
end

module Logging
  extend ::LittlePlugger
  extend ::LittlePlugger::ClassMethods
  def self.appenders(); end

  def self.backtrace(b=T.unsafe(nil)); end

  def self.basepath(); end

  def self.basepath=(path); end

  def self.cause_depth(); end

  def self.cause_depth=(value); end

  def self.clear_diagnostic_contexts(all=T.unsafe(nil)); end

  def self.color_scheme(name, opts=T.unsafe(nil)); end

  def self.format_as(f); end

  def self.globally(name=T.unsafe(nil)); end

  def self.init(*args); end

  def self.initialized?(); end

  def self.layouts(); end

  def self.level_num(level); end

  def self.levelify(level); end

  def self.libpath(*args, &block); end

  def self.log_internal(level=T.unsafe(nil), &block); end

  def self.log_internal_error(err); end

  def self.logger(*args); end

  def self.mdc(); end

  def self.ndc(); end

  def self.path(*args, &block); end

  def self.reopen(); end

  def self.reset(); end

  def self.show_configuration(io=T.unsafe(nil), logger=T.unsafe(nil), indent=T.unsafe(nil)); end

  def self.shutdown(*args); end

  def self.utc_offset(); end

  def self.utc_offset=(value); end

  def self.version(); end
end

module Marshal
  def self.restore(*_); end
end

class Method
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::MethodSource::MethodExtensions
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers
  def comment_describing(file, line_number); end

  def complete_expression?(str); end

  def expression_at(file, line_number, options=T.unsafe(nil)); end
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  def self.===(ex); end

  def self.rbx?(); end
end

module MethodSource::CodeHelpers
end

module MethodSource::MethodExtensions
  def comment(); end

  def source(); end
end

module MethodSource::MethodExtensions
  def self.included(klass); end
end

module MethodSource::ReeSourceLocation
  def source_location(); end
end

module MethodSource::ReeSourceLocation
end

module MethodSource::SourceLocation
end

module MethodSource::SourceLocation::MethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::MethodExtensions
end

module MethodSource::SourceLocation::ProcExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::ProcExtensions
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::UnboundMethodExtensions
end

module MethodSource::SourceLocation
end

class MethodSource::SourceNotFoundError
end

class MethodSource::SourceNotFoundError
end

module MethodSource
  extend ::MethodSource::CodeHelpers
  def self.comment_helper(source_location, name=T.unsafe(nil)); end

  def self.extract_code(source_location); end

  def self.lines_for(file_name, name=T.unsafe(nil)); end

  def self.source_helper(source_location, name=T.unsafe(nil)); end

  def self.valid_expression?(str); end
end

MiniTest = Minitest

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Minitest::AbstractReporter
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
end

class Minitest::Assertion
end

module Minitest::Assertions
  def _synchronize(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_mock(mock); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

class Minitest::CompositeReporter
end

class Minitest::Expectation
  def ctx(); end

  def ctx=(_); end

  def target(); end

  def target=(_); end
end

class Minitest::Expectation
  def self.[](*_); end

  def self.members(); end
end

module Minitest::Expectations
  def must_be(*args); end

  def must_be_close_to(*args); end

  def must_be_empty(*args); end

  def must_be_instance_of(*args); end

  def must_be_kind_of(*args); end

  def must_be_nil(*args); end

  def must_be_same_as(*args); end

  def must_be_silent(*args); end

  def must_be_within_delta(*args); end

  def must_be_within_epsilon(*args); end

  def must_equal(*args); end

  def must_include(*args); end

  def must_match(*args); end

  def must_output(*args); end

  def must_raise(*args); end

  def must_respond_to(*args); end

  def must_throw(*args); end

  def path_must_exist(*args); end

  def path_wont_exist(*args); end

  def wont_be(*args); end

  def wont_be_close_to(*args); end

  def wont_be_empty(*args); end

  def wont_be_instance_of(*args); end

  def wont_be_kind_of(*args); end

  def wont_be_nil(*args); end

  def wont_be_same_as(*args); end

  def wont_be_within_delta(*args); end

  def wont_be_within_epsilon(*args); end

  def wont_equal(*args); end

  def wont_include(*args); end

  def wont_match(*args); end

  def wont_respond_to(*args); end
end

module Minitest::Expectations
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

class Minitest::Mock
  def ===(*args, &b); end

  def __call(name, data); end

  def __respond_to?(*_); end

  def class(*args, &b); end

  def expect(name, retval, args=T.unsafe(nil), &blk); end

  def initialize(delegator=T.unsafe(nil)); end

  def inspect(*args, &b); end

  def instance_eval(*args, &b); end

  def instance_variables(*args, &b); end

  def method_missing(sym, *args, &block); end

  def object_id(*args, &b); end

  def public_send(*args, &b); end

  def respond_to?(sym, include_private=T.unsafe(nil)); end

  def send(*args, &b); end

  def to_s(*args, &b); end

  def verify(); end
end

class Minitest::Mock
end

module Minitest::Parallel
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class Minitest::Parallel::Executor
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Parallel::Test::ClassMethods
end

module Minitest::Parallel::Test
end

module Minitest::Parallel
end

class Minitest::ProgressReporter
end

class Minitest::ProgressReporter
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Reporter
end

class Minitest::Result
  include ::Minitest::Reportable
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Skip
end

class Minitest::Skip
end

class Minitest::Spec
  include ::Minitest::Spec::DSL::InstanceMethods
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  def after(_type=T.unsafe(nil), &block); end

  def before(_type=T.unsafe(nil), &block); end

  def children(); end

  def create(name, desc); end

  def desc(); end

  def describe_stack(); end

  def it(desc=T.unsafe(nil), &block); end

  def let(name, &block); end

  def name(); end

  def nuke_test_methods!(); end

  def register_spec_type(*args, &block); end

  def spec_type(desc, *additional); end

  def specify(desc=T.unsafe(nil), &block); end

  def subject(&block); end

  def to_s(); end
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL::InstanceMethods
  def _(value=T.unsafe(nil), &block); end

  def before_setup(); end

  def expect(value=T.unsafe(nil), &block); end

  def value(value=T.unsafe(nil), &block); end
end

module Minitest::Spec::DSL::InstanceMethods
end

module Minitest::Spec::DSL
  def self.extended(obj); end
end

class Minitest::Spec
  extend ::Minitest::Spec::DSL
  def self.current(); end
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end
end

class Minitest::StatisticsReporter
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::SummaryReporter
end

class Minitest::Test
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  def capture_exceptions(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
end

class Minitest::UnexpectedError
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit::TestCase
end

class Minitest::Unit::TestCase
end

class Minitest::Unit
  def self.after_tests(&b); end

  def self.autorun(); end
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.clock_time(); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run_one_method(klass, method_name); end
end

class MockExpectationError
end

class MockExpectationError
end

class Module
  def deprecate_constant(*_); end

  def infect_an_assertion(meth, new_name, dont_flip=T.unsafe(nil)); end

  def logger_name(); end

  def rake_extension(method); end

  def undef_method(*_); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module MultiJson
  include ::MultiJson::Options
  def adapter(); end

  def adapter=(new_adapter); end

  def cached_options(*_); end

  def current_adapter(options=T.unsafe(nil)); end

  def decode(string, options=T.unsafe(nil)); end

  def default_adapter(); end

  def default_engine(); end

  def default_options(); end

  def default_options=(value); end

  def dump(object, options=T.unsafe(nil)); end

  def encode(object, options=T.unsafe(nil)); end

  def engine(); end

  def engine=(new_adapter); end

  def load(string, options=T.unsafe(nil)); end

  def load_adapter(new_adapter); end

  def reset_cached_options!(*_); end

  def use(new_adapter); end

  def with_adapter(new_adapter); end

  def with_engine(new_adapter); end
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MultiJson::AdapterError
end

class MultiJson::AdapterError
  def self.build(original_exception); end
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::Options
  def default_dump_options(); end

  def default_load_options(); end

  def dump_options(*args); end

  def dump_options=(options); end

  def load_options(*args); end

  def load_options=(options); end
end

module MultiJson::Options
end

module MultiJson::OptionsCache
  def fetch(type, key, &block); end

  def reset(); end
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

module MultiJson::OptionsCache
  extend ::MultiJson::OptionsCache
end

class MultiJson::ParseError
  def data(); end
end

class MultiJson::ParseError
  def self.build(original_exception, data); end
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
end

module MultiJson
  extend ::MultiJson
  extend ::MultiJson::Options
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

class Net::HTTP
end

Net::HTTPSession::ProxyDelta = Net::HTTP::ProxyDelta

Net::HTTPSession::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP
end

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::Minitest::Expectations
  include ::PP::ObjectMixin
  def dclone(); end

  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def stub(name, val_or_callable, *block_args); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  HAVE_SYSLOG = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::MethodSource::MethodExtensions
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def yield(*_); end
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(); end

  def color=(value); end

  def command_state(); end

  def commands(); end

  def commands=(value); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(); end

  def editor=(value); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(value); end

  def hooks(); end

  def hooks=(value); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, b); end

  def inject_sticky_locals!(); end

  def input(); end

  def input=(value); end

  def input_array(); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(e); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(value); end

  def output_array(); end

  def output_ring(); end

  def pager(); end

  def pager=(value); end

  def pop_prompt(); end

  def print(); end

  def print=(value); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  CLIPPED_PRINT = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTROL_D_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_WHITELIST = ::T.let(nil, ::T.untyped)
  DEFAULT_HOOKS = ::T.let(nil, ::T.untyped)
  DEFAULT_PRINT = ::T.let(nil, ::T.untyped)
  DEFAULT_SYSTEM = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HOME_RC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  SIMPLE_PRINT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::Kernel
end

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::Pry = Pry

class Pry::BasicObject
end

class Pry::BlockCommand
  def call(*args); end

  def help(); end

  def opts(); end
end

class Pry::BlockCommand
end

class Pry::CLI
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.add_plugin_options(); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code
  def <<(line, lineno=T.unsafe(nil)); end

  def ==(other); end

  def after(lineno, lines=T.unsafe(nil)); end

  def alter(&block); end

  def around(lineno, lines=T.unsafe(nil)); end

  def before(lineno, lines=T.unsafe(nil)); end

  def between(start_line, end_line=T.unsafe(nil)); end

  def code_type(); end

  def code_type=(code_type); end

  def comment_describing(line_number); end

  def expression_at(line_number, consume=T.unsafe(nil)); end

  def grep(pattern); end

  def highlighted(); end

  def initialize(lines=T.unsafe(nil), start_line=T.unsafe(nil), code_type=T.unsafe(nil)); end

  def length(); end

  def max_lineno_width(); end

  def method_missing(name, *args, &block); end

  def nesting_at(line_number); end

  def print_to_output(output, color=T.unsafe(nil)); end

  def push(line, lineno=T.unsafe(nil)); end

  def raw(); end

  def select(&block); end

  def take_lines(start_line, num_lines); end

  def with_indentation(spaces=T.unsafe(nil)); end

  def with_line_numbers(y_n=T.unsafe(nil)); end

  def with_marker(lineno=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
end

class Pry::Code::LOC
  def ==(other); end

  def add_line_number(max_width=T.unsafe(nil), color=T.unsafe(nil)); end

  def add_marker(marker_lineno); end

  def colorize(code_type); end

  def handle_multiline_entries_from_edit_command(line, max_width); end

  def indent(distance); end

  def initialize(line, lineno); end

  def line(); end

  def lineno(); end

  def tuple(); end
end

class Pry::Code::LOC
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
  def self.from_file(filename, code_type=T.unsafe(nil)); end

  def self.from_method(meth, start_line=T.unsafe(nil)); end

  def self.from_module(mod, candidate_rank=T.unsafe(nil), start_line=T.unsafe(nil)); end
end

class Pry::CodeFile
  def code(); end

  def code_type(); end

  def initialize(filename, code_type=T.unsafe(nil)); end
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::CodeFile
end

class Pry::CodeObject
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def _pry_=(_pry_); end

  def command_lookup(); end

  def default_lookup(); end

  def empty_lookup(); end

  def initialize(str, _pry_, options=T.unsafe(nil)); end

  def method_or_class_lookup(); end

  def str(); end

  def str=(str); end

  def super_level(); end

  def super_level=(super_level); end

  def target(); end

  def target=(target); end
end

module Pry::CodeObject::Helpers
  def c_method?(); end

  def c_module?(); end

  def command?(); end

  def module_with_yard_docs?(); end

  def real_method_object?(); end
end

module Pry::CodeObject::Helpers
end

class Pry::CodeObject
  def self.lookup(str, _pry_, options=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def text(str, width=T.unsafe(nil)); end
  OBJ_COLOR = ::T.let(nil, ::T.untyped)
end

class Pry::ColorPrinter
  def self.pp(obj, out=T.unsafe(nil), width=T.unsafe(nil), newline=T.unsafe(nil)); end
end

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::Text
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def call_safely(*args); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def dependencies_met?(); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def text(); end

  def tokenize(val); end

  def use_unpatched_symbol(); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::AmendLine
end

class Pry::Command::AmendLine
end

class Pry::Command::Bang
end

class Pry::Command::Bang
end

class Pry::Command::BangPry
end

class Pry::Command::BangPry
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::AbstractFormatter
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Command::Cat::AbstractFormatter
end

class Pry::Command::Cat::ExceptionFormatter
  include ::Pry::Helpers::Text
  def _pry_(); end

  def ex(); end

  def format(); end

  def initialize(exception, _pry_, opts); end

  def opts(); end
end

class Pry::Command::Cat::ExceptionFormatter
end

class Pry::Command::Cat::FileFormatter
  def _pry_(); end

  def file_and_line(); end

  def file_with_embedded_line(); end

  def format(); end

  def initialize(file_with_embedded_line, _pry_, opts); end

  def opts(); end
end

class Pry::Command::Cat::FileFormatter
end

class Pry::Command::Cat::InputExpressionFormatter
  def format(); end

  def initialize(input_expressions, opts); end

  def input_expressions(); end

  def input_expressions=(input_expressions); end

  def opts(); end

  def opts=(opts); end
end

class Pry::Command::Cat::InputExpressionFormatter
end

class Pry::Command::Cat
end

class Pry::Command::Cd
end

class Pry::Command::Cd
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangeInspector
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::ChangePrompt
end

class Pry::Command::ClearScreen
end

class Pry::Command::ClearScreen
end

class Pry::Command::CodeCollector
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def args(); end

  def code_object(); end

  def content(); end

  def file(); end

  def file=(file); end

  def initialize(args, opts, _pry_); end

  def line_range(); end

  def obj_name(); end

  def opts(); end

  def pry_input_content(); end

  def pry_output_content(); end

  def restrict_to_lines(content, range); end
end

class Pry::Command::CodeCollector
  def self.inject_options(opt); end

  def self.input_expression_ranges(); end

  def self.input_expression_ranges=(input_expression_ranges); end

  def self.output_result_ranges(); end

  def self.output_result_ranges=(output_result_ranges); end
end

class Pry::Command::DisablePry
end

class Pry::Command::DisablePry
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Edit::ExceptionPatcher
  def _pry_(); end

  def _pry_=(_pry_); end

  def file_and_line(); end

  def file_and_line=(file_and_line); end

  def initialize(_pry_, state, exception_file_and_line); end

  def perform_patch(); end

  def state(); end

  def state=(state); end
end

class Pry::Command::Edit::ExceptionPatcher
end

module Pry::Command::Edit::FileAndLineLocator
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end

  def self.from_code_object(code_object, filename_argument); end

  def self.from_exception(exception, backtrace_level); end

  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Edit
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Exit
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitProgram
end

class Pry::Command::ExitProgram
end

class Pry::Command::FindMethod
end

class Pry::Command::FindMethod
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::FixIndent
end

class Pry::Command::FixIndent
end

class Pry::Command::GemCd
  def complete(str); end

  def process(gem); end
end

class Pry::Command::GemCd
end

class Pry::Command::GemInstall
  def process(gem); end
end

class Pry::Command::GemInstall
end

class Pry::Command::GemList
  def process(pattern=T.unsafe(nil)); end
end

class Pry::Command::GemList
end

class Pry::Command::GemOpen
  def complete(str); end

  def process(gem); end
end

class Pry::Command::GemOpen
end

class Pry::Command::GemReadme
  def process(name); end
end

class Pry::Command::GemReadme
end

class Pry::Command::GemSearch
  def process(str); end
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemSearch
end

class Pry::Command::GemStat
  def process(name); end
  FAIL_WHALE = ::T.let(nil, ::T.untyped)
  STAT_HOST = ::T.let(nil, ::T.untyped)
  STAT_PATH = ::T.let(nil, ::T.untyped)
  STAT_PORT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemStat
end

class Pry::Command::Gist
  def clipboard_content(content); end

  def comment_expression_result_for_gist(result); end

  def gist_content(content, filename); end

  def input_content(); end
end

class Pry::Command::Gist
end

class Pry::Command::Help
  def command_groups(); end

  def display_command(command); end

  def display_filtered_commands(search); end

  def display_filtered_search_results(search); end

  def display_index(groups); end

  def display_search(search); end

  def group_sort_key(group_name); end

  def help_text_for_commands(name, commands); end

  def normalize(key); end

  def search_hash(search, hash); end

  def sorted_commands(commands); end

  def sorted_group_names(groups); end

  def visible_commands(); end
end

class Pry::Command::Help
end

class Pry::Command::Hist
end

class Pry::Command::Hist
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::ImportSet
end

class Pry::Command::InstallCommand
  def process(name); end
end

class Pry::Command::InstallCommand
end

class Pry::Command::JumpTo
  def process(break_level); end
end

class Pry::Command::JumpTo
end

class Pry::Command::ListInspectors
end

class Pry::Command::ListInspectors
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
end

class Pry::Command::Ls::Formatter
  def _pry_(); end

  def grep=(grep); end

  def initialize(_pry_); end

  def write_out(); end
end

class Pry::Command::Ls::Formatter
end

class Pry::Command::Ls::Globals
  def initialize(opts, _pry_); end
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
end

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp(); end
end

class Pry::Command::Ls::Grep
end

class Pry::Command::Ls::InstanceVars
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::InstanceVars
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::JRubyHacks
end

class Pry::Command::Ls::LocalNames
  def initialize(no_user_opts, args, _pry_); end
end

class Pry::Command::Ls::LocalNames
end

class Pry::Command::Ls::LocalVars
  def initialize(opts, _pry_); end
end

class Pry::Command::Ls::LocalVars
end

class Pry::Command::Ls::LsEntity
  def _pry_(); end

  def entities_table(); end

  def initialize(opts); end
end

class Pry::Command::Ls::LsEntity
end

class Pry::Command::Ls::Methods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::Methods
end

module Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
end

class Pry::Command::Ls::SelfMethods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::SelfMethods
end

class Pry::Command::Ls
end

class Pry::Command::Nesting
end

class Pry::Command::Nesting
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Play
end

class Pry::Command::PryBacktrace
end

class Pry::Command::PryBacktrace
end

class Pry::Command::RaiseUp
end

class Pry::Command::RaiseUp
end

class Pry::Command::ReloadCode
end

class Pry::Command::ReloadCode
end

class Pry::Command::Reset
end

class Pry::Command::Reset
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::Ri
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::SaveFile
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShellCommand
end

class Pry::Command::ShellMode
end

class Pry::Command::ShellMode
end

class Pry::Command::ShowDoc
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowDoc
end

class Pry::Command::ShowInfo
  def code_object_header(code_object, line_num); end

  def code_object_with_accessible_source(code_object); end

  def complete(input); end

  def content_and_header_for_code_object(code_object); end

  def content_and_headers_for_all_module_candidates(mod); end

  def file_and_line_for(code_object); end

  def header(code_object); end

  def header_options(); end

  def initialize(*_); end

  def method_header(code_object, line_num); end

  def method_sections(code_object); end

  def module_header(code_object, line_num); end

  def no_definition_message(); end

  def obj_name(); end

  def show_all_modules?(code_object); end

  def start_line_for(code_object); end

  def use_line_numbers?(); end

  def valid_superclass?(code_object); end
end

class Pry::Command::ShowInfo
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowSource
  def content_for(code_object); end
end

class Pry::Command::ShowSource
end

class Pry::Command::Stat
end

class Pry::Command::Stat
end

class Pry::Command::SwitchTo
  def process(selection); end
end

class Pry::Command::SwitchTo
end

class Pry::Command::ToggleColor
  def color_toggle(); end
end

class Pry::Command::ToggleColor
end

class Pry::Command::Version
end

class Pry::Command::Version
end

class Pry::Command::WatchExpression
end

class Pry::Command::WatchExpression::Expression
  def _pry_(); end

  def changed?(); end

  def eval!(); end

  def initialize(_pry_, target, source); end

  def previous_value(); end

  def source(); end

  def target(); end

  def value(); end
end

class Pry::Command::WatchExpression::Expression
end

class Pry::Command::WatchExpression
end

class Pry::Command::Whereami
  def bad_option_combination?(); end

  def code(); end

  def code?(); end

  def initialize(*_); end

  def location(); end
end

class Pry::Command::Whereami
  def self.method_size_cutoff(); end

  def self.method_size_cutoff=(method_size_cutoff); end
end

class Pry::Command::Wtf
end

class Pry::Command::Wtf
end

class Pry::Command
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.hooks(); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandError
end

class Pry::CommandError
end

class Pry::CommandSet
  include ::Enumerable
  include ::Pry::Helpers::BaseHelpers
  def [](pattern); end

  def []=(pattern, command); end

  def add_command(command); end

  def alias_command(match, action, options=T.unsafe(nil)); end

  def block_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def complete(search, context=T.unsafe(nil)); end

  def create_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*searches); end

  def desc(search, description=T.unsafe(nil)); end

  def disabled_command(name_of_disabled_command, message, matcher=T.unsafe(nil)); end

  def each(&block); end

  def find_command(pattern); end

  def find_command_by_match_or_listing(match_or_listing); end

  def find_command_for_help(search); end

  def helper_module(); end

  def helpers(&block); end

  def import(*sets); end

  def import_from(set, *matches); end

  def initialize(*imported_sets, &block); end

  def keys(); end

  def list_commands(); end

  def process_line(val, context=T.unsafe(nil)); end

  def rename_command(new_match, search, options=T.unsafe(nil)); end

  def run_command(context, match, *args); end

  def to_h(); end

  def to_hash(); end

  def valid_command?(val); end
end

class Pry::CommandSet
end

class Pry::Config
  include ::Pry::Config::Behavior
end

module Pry::Config::Behavior
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def clear(); end

  def default(); end

  def eager_load!(); end

  def eql?(other); end

  def forget(key); end

  def initialize(default=T.unsafe(nil)); end

  def inspect(); end

  def key?(key); end

  def keys(); end

  def last_default(); end

  def merge!(other); end

  def method_missing(name, *args, &block); end

  def pretty_print(q); end

  def to_h(); end

  def to_hash(); end
  ASSIGNMENT = ::T.let(nil, ::T.untyped)
  INSPECT_REGEXP = ::T.let(nil, ::T.untyped)
  NODUP = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Behavior::Builder
  def assign(attributes, default=T.unsafe(nil)); end

  def from_hash(attributes, default=T.unsafe(nil)); end
end

module Pry::Config::Behavior::Builder
end

class Pry::Config::Behavior::ReservedKeyError
end

class Pry::Config::Behavior::ReservedKeyError
end

module Pry::Config::Behavior
  def self.included(klass); end
end

module Pry::Config::Convenience
  def config_shortcut(*names); end
  SHORTCUTS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Convenience
end

class Pry::Config::Default
  include ::Pry::Config::Behavior
  include ::Pry::Config::Memoization
  def auto_indent(); end

  def collision_warning(); end

  def color(); end

  def command_completions(); end

  def command_prefix(); end

  def commands(); end

  def completer(); end

  def control_d_handler(); end

  def correct_indent(); end

  def default_window_size(); end

  def disable_auto_reload(); end

  def editor(); end

  def exception_handler(); end

  def exception_whitelist(); end

  def exec_string(); end

  def extra_sticky_locals(); end

  def file_completions(); end

  def gist(); end

  def history(); end

  def hooks(); end

  def initialize(); end

  def input(); end

  def ls(); end

  def memory_size(); end

  def output(); end

  def output_prefix(); end

  def pager(); end

  def print(); end

  def prompt(); end

  def prompt_name(); end

  def prompt_safe_contexts(); end

  def quiet(); end

  def requires(); end

  def should_load_local_rc(); end

  def should_load_plugins(); end

  def should_load_rc(); end

  def should_load_requires(); end

  def should_trap_interrupts(); end

  def system(); end

  def windows_console_warning(); end
end

class Pry::Config::Default
  extend ::Pry::Config::Behavior::Builder
  extend ::Pry::Config::Memoization::ClassMethods
end

class Pry::Config::Lazy
  def call(); end

  def initialize(&block); end
end

class Pry::Config::Lazy
end

module Pry::Config::Memoization
  def memoized_methods(); end
  MEMOIZED_METHODS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Memoization::ClassMethods
  def def_memoized(method_table); end
end

module Pry::Config::Memoization::ClassMethods
end

module Pry::Config::Memoization
  def self.included(mod); end
end

class Pry::Config
  extend ::Pry::Config::Behavior::Builder
  def self.shortcuts(); end
end

class Pry::Editor
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def edit_tempfile_with_content(initial_content, line=T.unsafe(nil)); end

  def initialize(_pry_); end

  def invoke_editor(file, line, blocking=T.unsafe(nil)); end
end

class Pry::Editor
end

module Pry::ExtendCommandBundle
end

module Pry::ExtendCommandBundle
end

module Pry::Forwardable
  include ::Forwardable
  def def_private_delegators(target, *private_delegates); end
end

module Pry::Forwardable
end

module Pry::FrozenObjectException
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

module Pry::Helpers
end

module Pry::Helpers::BaseHelpers
  def colorize_code(code); end

  def command_dependencies_met?(options); end

  def find_command(name, set=T.unsafe(nil)); end

  def heading(text); end

  def highlight(string, regexp, highlight_color=T.unsafe(nil)); end

  def jruby?(); end

  def jruby_19?(); end

  def linux?(); end

  def mac_osx?(); end

  def mri?(); end

  def mri_19?(); end

  def mri_2?(); end

  def not_a_real_file?(file); end

  def safe_send(obj, method, *args, &block); end

  def silence_warnings(); end

  def stagger_output(text, _out=T.unsafe(nil)); end

  def use_ansi_codes?(); end

  def windows?(); end

  def windows_ansi?(); end
end

module Pry::Helpers::BaseHelpers
  extend ::Pry::Helpers::BaseHelpers
end

module Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::CommandHelpers
  def self.absolute_index_number(line_number, array_length); end

  def self.absolute_index_range(range_or_number, array_length); end

  def self.command_error(message, omit_help, klass=T.unsafe(nil)); end

  def self.get_method_or_raise(name, target, opts=T.unsafe(nil), omit_help=T.unsafe(nil)); end

  def self.internal_binding?(target); end

  def self.one_index_number(line_number); end

  def self.one_index_range(range); end

  def self.one_index_range_or_number(range_or_number); end

  def self.restrict_to_lines(content, lines); end

  def self.set_file_and_dir_locals(file_name, _pry_=T.unsafe(nil), target=T.unsafe(nil)); end

  def self.temp_file(ext=T.unsafe(nil)); end

  def self.unindent(text, left_padding=T.unsafe(nil)); end
end

module Pry::Helpers::DocumentationHelpers
end

module Pry::Helpers::DocumentationHelpers
  def self.get_comment_content(comment); end

  def self.process_comment_markup(comment); end

  def self.process_rdoc(comment); end

  def self.process_yardoc(comment); end

  def self.process_yardoc_tag(comment, tag); end

  def self.strip_comments_from_c_code(code); end

  def self.strip_leading_whitespace(text); end
end

module Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::OptionsHelpers
  def self.method_object(); end

  def self.method_options(opt); end
end

module Pry::Helpers::Platform
end

module Pry::Helpers::Platform
  def self.jruby?(); end

  def self.jruby_19?(); end

  def self.linux?(); end

  def self.mac_osx?(); end

  def self.mri?(); end

  def self.mri_19?(); end

  def self.mri_2?(); end

  def self.windows?(); end

  def self.windows_ansi?(); end
end

class Pry::Helpers::Table
  def ==(other); end

  def column_count(); end

  def column_count=(n); end

  def columns(); end

  def fits_on_line?(line_length); end

  def initialize(items, args, config=T.unsafe(nil)); end

  def items(); end

  def items=(items); end

  def rows_to_s(style=T.unsafe(nil)); end

  def to_a(); end
end

class Pry::Helpers::Table
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bold(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def default(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def indent(text, chars); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def no_color(); end

  def no_pager(); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def strip_color(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def with_line_numbers(text, offset, color=T.unsafe(nil)); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  extend ::Pry::Helpers::Text
end

module Pry::Helpers
  def self.tablify(things, line_length, config=T.unsafe(nil)); end

  def self.tablify_or_one_line(heading, things, config=T.unsafe(nil)); end

  def self.tablify_to_screen_width(things, options, config=T.unsafe(nil)); end
end

class Pry::History
  def <<(line); end

  def clear(); end

  def clearer(); end

  def clearer=(clearer); end

  def filter(history); end

  def history_line_count(); end

  def initialize(options=T.unsafe(nil)); end

  def load(); end

  def loader(); end

  def loader=(loader); end

  def original_lines(); end

  def push(line); end

  def pusher(); end

  def pusher=(pusher); end

  def restore_default_behavior(); end

  def saver(); end

  def saver=(saver); end

  def session_line_count(); end

  def to_a(); end
end

class Pry::History
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
end

class Pry::Indent
  include ::Pry::Helpers::BaseHelpers
  def correct_indentation(prompt, code, overhang=T.unsafe(nil)); end

  def current_prefix(); end

  def end_of_statement?(last_token, last_kind); end

  def in_string?(); end

  def indent(input); end

  def indent_level(); end

  def indentation_delta(tokens); end

  def module_nesting(); end

  def open_delimiters(); end

  def open_delimiters_line(); end

  def reset(); end

  def stack(); end

  def tokenize(string); end

  def track_delimiter(token); end

  def track_module_nesting(token, kind); end

  def track_module_nesting_end(token, kind=T.unsafe(nil)); end
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent
  def self.indent(str); end

  def self.nesting_at(str, line_number); end
end

class Pry::InputLock
  def __with_ownership(&block); end

  def enter_interruptible_region(); end

  def interruptible_region(&block); end

  def leave_interruptible_region(); end

  def with_ownership(&block); end
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock
  def self.for(input); end

  def self.global_lock(); end

  def self.global_lock=(global_lock); end

  def self.input_locks(); end

  def self.input_locks=(input_locks); end
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(e); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::LastException
end

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def ==(obj); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def pry_method?(); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def method_missing(meth_name, *args, &block); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Disowned
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def get_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, b); end

  def self.weird_method?(method, b); end
end

class Pry::Method
  extend ::Pry::Helpers::BaseHelpers
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_common(obj, _method_type=T.unsafe(nil), include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(b); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::MethodNotFound
end

class Pry::MethodNotFound
end

class Pry::NoCommandError
  def initialize(match, owner); end
end

class Pry::NoCommandError
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
end

class Pry::ObsoleteError
end

class Pry::ObsoleteError
end

class Pry::Output
  def <<(*objs); end

  def _pry_(); end

  def decolorize_maybe(str); end

  def initialize(_pry_); end

  def method_missing(name, *args, &block); end

  def print(*objs); end

  def puts(*objs); end

  def tty?(); end

  def write(*objs); end
end

class Pry::Output
end

class Pry::Pager
  def _pry_(); end

  def initialize(_pry_); end

  def open(); end

  def page(text); end
end

class Pry::Pager::NullPager
  def <<(str); end

  def close(); end

  def initialize(out); end

  def print(str); end

  def puts(str); end

  def write(str); end
end

class Pry::Pager::NullPager
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?(); end

  def record(str); end

  def reset(); end
end

class Pry::Pager::PageTracker
end

class Pry::Pager::SimplePager
  def initialize(*_); end
end

class Pry::Pager::SimplePager
end

class Pry::Pager::StopPaging
end

class Pry::Pager::StopPaging
end

class Pry::Pager::SystemPager
  def initialize(*_); end
end

class Pry::Pager::SystemPager
  def self.available?(); end

  def self.default_pager(); end
end

class Pry::Pager
end

class Pry::PluginManager
  def load_plugins(); end

  def locate_plugins(); end

  def plugins(); end
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager::NoPlugin
  def initialize(name); end

  def method_missing(*_args); end
end

class Pry::PluginManager::NoPlugin
end

class Pry::PluginManager::Plugin
  def activate!(); end

  def active(); end

  def active=(active); end

  def active?(); end

  def disable!(); end

  def enable!(); end

  def enabled(); end

  def enabled=(enabled); end

  def enabled?(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def initialize(name, gem_name, spec, enabled); end

  def load_cli_options(); end

  def name(); end

  def name=(name); end

  def spec(); end

  def spec=(spec); end

  def supported?(); end
end

class Pry::PluginManager::Plugin
end

class Pry::PluginManager
end

module Pry::Prompt
  DEFAULT_NAME = ::T.let(nil, ::T.untyped)
  SAFE_CONTEXTS = ::T.let(nil, ::T.untyped)
end

module Pry::Prompt
  def self.[](prompt_name); end

  def self.add(prompt_name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def initialize(pry, options=T.unsafe(nil)); end

  def input(*args, &block); end

  def output(*args, &block); end

  def pry(); end

  def pry=(pry); end

  def start(); end
end

class Pry::REPL
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.start(options); end
end

module Pry::RescuableException
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def command?(); end

  def initialize(is_command, retval=T.unsafe(nil)); end

  def retval(); end

  def void_command?(); end
end

class Pry::Result
end

class Pry::Ring
  def <<(value); end

  def [](index); end

  def clear(); end

  def count(); end

  def initialize(max_size); end

  def max_size(); end

  def size(); end

  def to_a(); end
end

class Pry::Ring
end

module Pry::Rubygem
end

module Pry::Rubygem
  def self.complete(so_far); end

  def self.install(name); end

  def self.installed?(name); end

  def self.list(pattern=T.unsafe(nil)); end

  def self.spec(name); end
end

class Pry::Slop
  include ::Enumerable
  def [](key); end

  def add_callback(label, &block); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def command(command, options=T.unsafe(nil), &block); end

  def config(); end

  def description(desc=T.unsafe(nil)); end

  def description=(desc); end

  def each(&block); end

  def fetch_command(command); end

  def fetch_option(key); end

  def get(key); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def missing(); end

  def on(*objects, &block); end

  def opt(*objects, &block); end

  def option(*objects, &block); end

  def options(); end

  def parse(items=T.unsafe(nil), &block); end

  def parse!(items=T.unsafe(nil), &block); end

  def present?(*keys); end

  def run(callable=T.unsafe(nil), &block); end

  def separator(text); end

  def strict?(); end

  def to_h(include_commands=T.unsafe(nil)); end

  def to_hash(include_commands=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Commands
  include ::Enumerable
  def [](key); end

  def arguments(); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def commands(); end

  def config(); end

  def default(config=T.unsafe(nil), &block); end

  def each(&block); end

  def get(key); end

  def global(config=T.unsafe(nil), &block); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def on(command, config=T.unsafe(nil), &block); end

  def parse(items=T.unsafe(nil)); end

  def parse!(items=T.unsafe(nil)); end

  def present?(key); end

  def to_hash(); end
end

class Pry::Slop::Commands
end

class Pry::Slop::Error
end

class Pry::Slop::Error
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::Option
  def accepts_optional_argument?(); end

  def argument?(); end

  def argument_in_value(); end

  def argument_in_value=(argument_in_value); end

  def as?(); end

  def autocreated?(); end

  def call(*objects); end

  def callback?(); end

  def config(); end

  def count(); end

  def count=(count); end

  def default?(); end

  def delimiter?(); end

  def description(); end

  def expects_argument?(); end

  def help(); end

  def initialize(slop, short, long, description, config=T.unsafe(nil), &block); end

  def key(); end

  def limit?(); end

  def long(); end

  def match?(); end

  def optional?(); end

  def optional_argument?(); end

  def required?(); end

  def short(); end

  def tail?(); end

  def types(); end

  def value(); end

  def value=(new_value); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
end

class Pry::Slop
  def self.optspec(string, config=T.unsafe(nil)); end

  def self.parse(items=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.parse!(items=T.unsafe(nil), config=T.unsafe(nil), &block); end
end

class Pry::Terminal
end

class Pry::Terminal
  def self.actual_screen_size(); end

  def self.height!(); end

  def self.screen_size(); end

  def self.screen_size_according_to_ansicon_env(); end

  def self.screen_size_according_to_env(); end

  def self.screen_size_according_to_io_console(); end

  def self.screen_size_according_to_readline(); end

  def self.size!(default=T.unsafe(nil)); end

  def self.width!(); end
end

module Pry::TooSafeException
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::UserError
end

module Pry::UserError
end

class Pry::WrappedModule
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::CodeObject::Helpers
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def class?(*args, &block); end

  def doc(); end

  def file(); end

  def initialize(wrapper, rank); end

  def line(); end

  def module?(*args, &block); end

  def nonblank_name(*args, &block); end

  def number_of_candidates(*args, &block); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def wrapped(*args, &block); end
end

class Pry::WrappedModule::Candidate
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  extend ::Pry::Config::Convenience
  def self.Code(obj); end

  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(); end

  def self.color=(value); end

  def self.commands(); end

  def self.commands=(value); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.default_editor_for_platform(); end

  def self.editor(); end

  def self.editor=(value); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(); end

  def self.exception_handler=(value); end

  def self.extra_sticky_locals(); end

  def self.extra_sticky_locals=(value); end

  def self.final_session_setup(); end

  def self.history(); end

  def self.history=(history); end

  def self.hooks(); end

  def self.hooks=(value); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(); end

  def self.input=(value); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.lazy(&block); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_plugins(*args, &block); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.locate_plugins(*args, &block); end

  def self.main(); end

  def self.memory_size(); end

  def self.memory_size=(value); end

  def self.output(); end

  def self.output=(value); end

  def self.pager(); end

  def self.pager=(value); end

  def self.plugins(*args, &block); end

  def self.print(); end

  def self.print=(value); end

  def self.prompt(); end

  def self.prompt=(value); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def clone(); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def clone(); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def clone(); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def [](name_or_index); end

  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def clone(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil), &blk); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def clone(); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
end

module REXML::Security
end

module REXML::Security
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

class REXML::SyncEnumerator
  include ::Enumerable
  def each(&blk); end

  def initialize(*enums); end

  def length(); end

  def size(); end
end

class REXML::SyncEnumerator
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def clone(); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def clone(); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def initialize(strict: T.unsafe(nil)); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def excluded_from_list?(fn); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, &block); end

  def chdir(*args, &block); end

  def chmod(*args, &block); end

  def chmod_R(*args, &block); end

  def chown(*args, &block); end

  def chown_R(*args, &block); end

  def copy(*args, &block); end

  def cp(*args, &block); end

  def cp_lr(*args, &block); end

  def cp_r(*args, &block); end

  def install(*args, &block); end

  def link(*args, &block); end

  def ln(*args, &block); end

  def ln_s(*args, &block); end

  def ln_sf(*args, &block); end

  def makedirs(*args, &block); end

  def mkdir(*args, &block); end

  def mkdir_p(*args, &block); end

  def mkpath(*args, &block); end

  def move(*args, &block); end

  def mv(*args, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_merge_option(args, defaults); end

  def rake_output_message(message); end

  def remove(*args, &block); end

  def rm(*args, &block); end

  def rm_f(*args, &block); end

  def rm_r(*args, &block); end

  def rm_rf(*args, &block); end

  def rmdir(*args, &block); end

  def rmtree(*args, &block); end

  def safe_unlink(*args, &block); end

  def symlink(*args, &block); end

  def touch(*args, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

RakeFileUtils = Rake::FileUtilsExt

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

class ReentrantMutex
  def original_synchronize(); end
end

class ReentrantMutex
end

class Regexp
  include ::ToRegexp::Regexp
  def match?(*_); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

module Rufus
  DURATIONS = ::T.let(nil, ::T.untyped)
  DURATIONS2 = ::T.let(nil, ::T.untyped)
  DURATIONS2M = ::T.let(nil, ::T.untyped)
  DURATION_LETTERS = ::T.let(nil, ::T.untyped)
  DU_KEYS = ::T.let(nil, ::T.untyped)
end

class Rufus::CronLine
  def days(); end

  def hours(); end

  def initialize(line); end

  def matches?(time); end

  def minutes(); end

  def months(); end

  def next_time(now=T.unsafe(nil)); end

  def original(); end

  def previous_time(now=T.unsafe(nil)); end

  def seconds(); end

  def timezone(); end

  def to_array(); end

  def weekdays(); end
  DAY_S = ::T.let(nil, ::T.untyped)
  RANGE_REGEX = ::T.let(nil, ::T.untyped)
  WEEKDAYS = ::T.let(nil, ::T.untyped)
  WEEK_S = ::T.let(nil, ::T.untyped)
end

class Rufus::CronLine
end

module Rufus::Schedulable
end

module Rufus::Schedulable
  extend ::Rufus::Scheduler::Schedulable
end

module Rufus::Scheduler
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rufus::Scheduler::AtJob
end

class Rufus::Scheduler::AtJob
end

class Rufus::Scheduler::CronJob
  def cron_line(); end

  def determine_at(); end

  def initialize(scheduler, cron_string, params, &block); end

  def next_time(from=T.unsafe(nil)); end

  def trigger_if_matches(time); end
end

class Rufus::Scheduler::CronJob
end

class Rufus::Scheduler::CronJobQueue
end

class Rufus::Scheduler::CronJobQueue
end

class Rufus::Scheduler::EmScheduler
  def join(); end

  def start(); end

  def stop(opts=T.unsafe(nil)); end
end

class Rufus::Scheduler::EmScheduler
end

class Rufus::Scheduler::EveryJob
  def determine_frequency(); end

  def frequency(); end

  def schedule_next(); end

  def trigger(); end
end

class Rufus::Scheduler::EveryJob
end

class Rufus::Scheduler::InJob
  def initialize(scheduler, t, params); end

  def parent(); end
end

class Rufus::Scheduler::InJob
end

class Rufus::Scheduler::Job
  def block(); end

  def initialize(scheduler, t, params, &block); end

  def job_id(); end

  def known_params(); end

  def last(); end

  def last_job_thread(); end

  def params(); end

  def pause(); end

  def paused?(); end

  def raise_on_unknown_params(); end

  def resume(); end

  def running(); end

  def running?(); end

  def schedule_info(); end

  def scheduler(); end

  def scheduler=(scheduler); end

  def t(); end

  def tags(); end

  def tags=(tags); end

  def trigger(t=T.unsafe(nil)); end

  def trigger_block(); end

  def unschedule(); end
end

class Rufus::Scheduler::Job
  def self.known_params(*args); end
end

class Rufus::Scheduler::JobQueue
  def <<(job); end

  def delete(job_id); end

  def job_to_trigger(now); end

  def select(type); end

  def size(); end

  def to_h(); end

  def trigger_matching_jobs(); end

  def unschedule(job_id); end
  JOB_TYPES = ::T.let(nil, ::T.untyped)
end

class Rufus::Scheduler::JobQueue
end

module Rufus::Scheduler::LegacyMethods
  def at_job_count(); end

  def cron_job_count(); end

  def every_job_count(); end

  def find_jobs(tag=T.unsafe(nil)); end

  def pending_job_count(); end

  def precision(); end
end

module Rufus::Scheduler::LegacyMethods
end

class Rufus::Scheduler::PlainScheduler
  def join(); end

  def start(); end

  def stop(opts=T.unsafe(nil)); end
end

class Rufus::Scheduler::PlainScheduler
end

module Rufus::Scheduler::Schedulable
  def call(job); end

  def trigger(params); end
end

module Rufus::Scheduler::Schedulable
end

class Rufus::Scheduler::SchedulerCore
  include ::Rufus::Scheduler::LegacyMethods
  def add_cron_job(job); end

  def add_job(job); end

  def all_jobs(); end

  def at(t, s=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def combine_opts(schedulable, opts); end

  def complain_if_blocking_and_timeout(job); end

  def cron(cronstring, s=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def cron_jobs(); end

  def do_handle_exception(job, exception); end

  def every(t, s=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def find(job_or_id); end

  def find_by_tag(tag); end

  def get_queue(type, opts); end

  def in(t, s=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def initialize(opts=T.unsafe(nil)); end

  def jobs(); end

  def options(); end

  def pause(job_or_id); end

  def resume(job_or_id); end

  def running_jobs(); end

  def schedule(cronstring, s=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def schedule_at(t, s=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def schedule_every(t, s=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def schedule_in(t, s=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def step(); end

  def synchronize_with_mutex(mutex, &block); end

  def terminate_all_jobs(); end

  def trigger_job(params, &block); end

  def trigger_threads(); end

  def unschedule(job_or_id); end

  def unschedule_by_tag(tag); end
end

class Rufus::Scheduler::SchedulerCore
  def self.start_new(opts=T.unsafe(nil)); end
end

class Rufus::Scheduler::SignalScheduler
  def stop(opts=T.unsafe(nil)); end
end

class Rufus::Scheduler::SignalScheduler
end

class Rufus::Scheduler::SimpleJob
  def at(); end

  def determine_at(); end

  def next_time(); end
end

class Rufus::Scheduler::SimpleJob
end

class Rufus::Scheduler::TimeOutError
end

class Rufus::Scheduler::TimeOutError
end

module Rufus::Scheduler
  def self.is_cron_string(s); end

  def self.new(opts=T.unsafe(nil)); end

  def self.start_new(opts=T.unsafe(nil)); end
end

module Rufus
  def self.at_to_f(at); end

  def self.current_time_millis(); end

  def self.duration_to_f(s); end

  def self.now(); end

  def self.parse_duration_string(string); end

  def self.parse_time_string(string); end

  def self.time_to_iso8601_date(time); end

  def self.to_datetime(time); end

  def self.to_duration_hash(seconds, options=T.unsafe(nil)); end

  def self.to_duration_string(seconds, options=T.unsafe(nil)); end

  def self.to_gm_time(dtime); end

  def self.to_iso8601_date(date); end

  def self.to_local_time(dtime); end

  def self.to_ruby_time(sdate); end

  def self.to_time_string(seconds, options=T.unsafe(nil)); end

  def self.to_ttime(d, method); end
end

module SQLite3
  SQLITE_VERSION = ::T.let(nil, ::T.untyped)
  SQLITE_VERSION_NUMBER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SQLite3::AbortException
end

class SQLite3::AbortException
end

class SQLite3::AuthorizationException
end

class SQLite3::AuthorizationException
end

class SQLite3::Backup
  def finish(); end

  def initialize(_, _1, _2, _3); end

  def pagecount(); end

  def remaining(); end

  def step(_); end
end

class SQLite3::Backup
end

class SQLite3::Blob
end

class SQLite3::Blob
end

class SQLite3::BusyException
end

class SQLite3::BusyException
end

class SQLite3::CantOpenException
end

class SQLite3::CantOpenException
end

module SQLite3::Constants
end

module SQLite3::Constants::ColumnType
  BLOB = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ColumnType
end

module SQLite3::Constants::ErrorCode
  ABORT = ::T.let(nil, ::T.untyped)
  AUTH = ::T.let(nil, ::T.untyped)
  BUSY = ::T.let(nil, ::T.untyped)
  CANTOPEN = ::T.let(nil, ::T.untyped)
  CONSTRAINT = ::T.let(nil, ::T.untyped)
  CORRUPT = ::T.let(nil, ::T.untyped)
  DONE = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FULL = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  INTERRUPT = ::T.let(nil, ::T.untyped)
  IOERR = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MISMATCH = ::T.let(nil, ::T.untyped)
  MISUSE = ::T.let(nil, ::T.untyped)
  NOLFS = ::T.let(nil, ::T.untyped)
  NOMEM = ::T.let(nil, ::T.untyped)
  NOTFOUND = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  PERM = ::T.let(nil, ::T.untyped)
  PROTOCOL = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  ROW = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  TOOBIG = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ErrorCode
end

module SQLite3::Constants::Open
  AUTOPROXY = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETEONCLOSE = ::T.let(nil, ::T.untyped)
  EXCLUSIVE = ::T.let(nil, ::T.untyped)
  FULLMUTEX = ::T.let(nil, ::T.untyped)
  MAIN_DB = ::T.let(nil, ::T.untyped)
  MAIN_JOURNAL = ::T.let(nil, ::T.untyped)
  MASTER_JOURNAL = ::T.let(nil, ::T.untyped)
  MEMORY = ::T.let(nil, ::T.untyped)
  NOMUTEX = ::T.let(nil, ::T.untyped)
  PRIVATECACHE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  READWRITE = ::T.let(nil, ::T.untyped)
  SHAREDCACHE = ::T.let(nil, ::T.untyped)
  SUBJOURNAL = ::T.let(nil, ::T.untyped)
  TEMP_DB = ::T.let(nil, ::T.untyped)
  TEMP_JOURNAL = ::T.let(nil, ::T.untyped)
  TRANSIENT_DB = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  WAL = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::Open
end

module SQLite3::Constants::TextRep
  ANY = ::T.let(nil, ::T.untyped)
  DETERMINISTIC = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::TextRep
end

module SQLite3::Constants
end

class SQLite3::ConstraintException
end

class SQLite3::ConstraintException
end

class SQLite3::CorruptException
end

class SQLite3::CorruptException
end

class SQLite3::Database
  include ::SQLite3::Pragmas
  def authorizer(&block); end

  def authorizer=(authorizer); end

  def busy_handler(*_); end

  def busy_timeout(_); end

  def busy_timeout=(busy_timeout); end

  def changes(); end

  def close(); end

  def closed?(); end

  def collation(_, _1); end

  def collations(); end

  def commit(); end

  def complete?(_); end

  def create_aggregate(name, arity, step=T.unsafe(nil), finalize=T.unsafe(nil), text_rep=T.unsafe(nil), &block); end

  def create_aggregate_handler(handler); end

  def create_function(name, arity, text_rep=T.unsafe(nil), &block); end

  def define_aggregator(name, aggregator); end

  def define_function(_); end

  def define_function_with_flags(_, _1); end

  def enable_load_extension(_); end

  def errcode(); end

  def errmsg(); end

  def execute(sql, bind_vars=T.unsafe(nil), *args, &block); end

  def execute2(sql, *bind_vars); end

  def execute_batch(sql, bind_vars=T.unsafe(nil), *args); end

  def execute_batch2(sql, &block); end

  def extended_result_codes=(extended_result_codes); end

  def filename(db_name=T.unsafe(nil)); end

  def get_first_row(sql, *bind_vars); end

  def get_first_value(sql, *bind_vars); end

  def initialize(file, options=T.unsafe(nil), zvfs=T.unsafe(nil)); end

  def interrupt(); end

  def last_insert_row_id(); end

  def load_extension(_); end

  def prepare(sql); end

  def query(sql, bind_vars=T.unsafe(nil), *args); end

  def readonly?(); end

  def results_as_hash(); end

  def results_as_hash=(results_as_hash); end

  def rollback(); end

  def total_changes(); end

  def trace(*_); end

  def transaction(mode=T.unsafe(nil)); end

  def transaction_active?(); end

  def translate_from_db(types, row); end

  def translator(); end

  def type_translation(); end

  def type_translation=(value); end
  NULL_TRANSLATOR = ::T.let(nil, ::T.untyped)
end

class SQLite3::Database::FunctionProxy
  def [](key); end

  def []=(key, value); end

  def count(); end

  def result(); end

  def result=(result); end

  def set_error(error); end
end

class SQLite3::Database::FunctionProxy
end

class SQLite3::Database
  def self.quote(string); end
end

class SQLite3::EmptyException
end

class SQLite3::EmptyException
end

class SQLite3::Exception
  def code(); end
end

class SQLite3::Exception
end

class SQLite3::FormatException
end

class SQLite3::FormatException
end

class SQLite3::FullException
end

class SQLite3::FullException
end

class SQLite3::IOException
end

class SQLite3::IOException
end

class SQLite3::InternalException
end

class SQLite3::InternalException
end

class SQLite3::InterruptException
end

class SQLite3::InterruptException
end

class SQLite3::LockedException
end

class SQLite3::LockedException
end

class SQLite3::MemoryException
end

class SQLite3::MemoryException
end

class SQLite3::MismatchException
end

class SQLite3::MismatchException
end

class SQLite3::MisuseException
end

class SQLite3::MisuseException
end

class SQLite3::NotADatabaseException
end

class SQLite3::NotADatabaseException
end

class SQLite3::NotFoundException
end

class SQLite3::NotFoundException
end

class SQLite3::PermissionException
end

class SQLite3::PermissionException
end

module SQLite3::Pragmas
  def application_id(); end

  def application_id=(integer); end

  def auto_vacuum(); end

  def auto_vacuum=(mode); end

  def automatic_index(); end

  def automatic_index=(mode); end

  def busy_timeout(); end

  def busy_timeout=(milliseconds); end

  def cache_size(); end

  def cache_size=(size); end

  def cache_spill(); end

  def cache_spill=(mode); end

  def case_sensitive_like=(mode); end

  def cell_size_check(); end

  def cell_size_check=(mode); end

  def checkpoint_fullfsync(); end

  def checkpoint_fullfsync=(mode); end

  def collation_list(&block); end

  def compile_options(&block); end

  def count_changes(); end

  def count_changes=(mode); end

  def data_version(); end

  def database_list(&block); end

  def default_cache_size(); end

  def default_cache_size=(size); end

  def default_synchronous(); end

  def default_synchronous=(mode); end

  def default_temp_store(); end

  def default_temp_store=(mode); end

  def defer_foreign_keys(); end

  def defer_foreign_keys=(mode); end

  def encoding(); end

  def encoding=(mode); end

  def foreign_key_check(*table, &block); end

  def foreign_key_list(table, &block); end

  def foreign_keys(); end

  def foreign_keys=(mode); end

  def freelist_count(); end

  def full_column_names(); end

  def full_column_names=(mode); end

  def fullfsync(); end

  def fullfsync=(mode); end

  def get_boolean_pragma(name); end

  def get_enum_pragma(name); end

  def get_int_pragma(name); end

  def get_query_pragma(name, *parms, &block); end

  def ignore_check_constraints=(mode); end

  def incremental_vacuum(pages, &block); end

  def index_info(index, &block); end

  def index_list(table, &block); end

  def index_xinfo(index, &block); end

  def integrity_check(*num_errors, &block); end

  def journal_mode(); end

  def journal_mode=(mode); end

  def journal_size_limit(); end

  def journal_size_limit=(size); end

  def legacy_file_format(); end

  def legacy_file_format=(mode); end

  def locking_mode(); end

  def locking_mode=(mode); end

  def max_page_count(); end

  def max_page_count=(size); end

  def mmap_size(); end

  def mmap_size=(size); end

  def page_count(); end

  def page_size(); end

  def page_size=(size); end

  def parser_trace=(mode); end

  def query_only(); end

  def query_only=(mode); end

  def quick_check(*num_errors, &block); end

  def read_uncommitted(); end

  def read_uncommitted=(mode); end

  def recursive_triggers(); end

  def recursive_triggers=(mode); end

  def reverse_unordered_selects(); end

  def reverse_unordered_selects=(mode); end

  def schema_cookie(); end

  def schema_cookie=(cookie); end

  def schema_version(); end

  def schema_version=(version); end

  def secure_delete(); end

  def secure_delete=(mode); end

  def set_boolean_pragma(name, mode); end

  def set_enum_pragma(name, mode, enums); end

  def set_int_pragma(name, value); end

  def short_column_names(); end

  def short_column_names=(mode); end

  def shrink_memory(); end

  def soft_heap_limit(); end

  def soft_heap_limit=(mode); end

  def stats(&block); end

  def synchronous(); end

  def synchronous=(mode); end

  def table_info(table); end

  def temp_store(); end

  def temp_store=(mode); end

  def threads(); end

  def threads=(count); end

  def user_cookie(); end

  def user_cookie=(cookie); end

  def user_version(); end

  def user_version=(version); end

  def vdbe_addoptrace=(mode); end

  def vdbe_debug=(mode); end

  def vdbe_listing=(mode); end

  def vdbe_trace(); end

  def vdbe_trace=(mode); end

  def wal_autocheckpoint(); end

  def wal_autocheckpoint=(mode); end

  def wal_checkpoint(); end

  def wal_checkpoint=(mode); end

  def writable_schema=(mode); end
  AUTO_VACUUM_MODES = ::T.let(nil, ::T.untyped)
  ENCODINGS = ::T.let(nil, ::T.untyped)
  JOURNAL_MODES = ::T.let(nil, ::T.untyped)
  LOCKING_MODES = ::T.let(nil, ::T.untyped)
  SYNCHRONOUS_MODES = ::T.let(nil, ::T.untyped)
  TEMP_STORE_MODES = ::T.let(nil, ::T.untyped)
  WAL_CHECKPOINTS = ::T.let(nil, ::T.untyped)
end

module SQLite3::Pragmas
end

class SQLite3::ProtocolException
end

class SQLite3::ProtocolException
end

class SQLite3::RangeException
end

class SQLite3::RangeException
end

class SQLite3::ReadOnlyException
end

class SQLite3::ReadOnlyException
end

class SQLite3::ResultSet
  include ::Enumerable
  def close(); end

  def closed?(); end

  def columns(); end

  def each(&blk); end

  def each_hash(); end

  def eof?(); end

  def initialize(db, stmt); end

  def next(); end

  def next_hash(); end

  def reset(*bind_params); end

  def types(); end
end

class SQLite3::ResultSet::ArrayWithTypes
  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::ArrayWithTypes
end

class SQLite3::ResultSet::ArrayWithTypesAndFields
  def fields(); end

  def fields=(fields); end

  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::ArrayWithTypesAndFields
end

class SQLite3::ResultSet::HashWithTypesAndFields
  def [](key); end

  def fields(); end

  def fields=(fields); end

  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::HashWithTypesAndFields
end

class SQLite3::ResultSet
end

class SQLite3::SQLException
end

class SQLite3::SQLException
end

class SQLite3::SchemaChangedException
end

class SQLite3::SchemaChangedException
end

class SQLite3::Statement
  include ::Enumerable
  def active?(); end

  def bind_param(_, _1); end

  def bind_parameter_count(); end

  def bind_params(*bind_vars); end

  def clear_bindings!(); end

  def close(); end

  def closed?(); end

  def column_count(); end

  def column_decltype(_); end

  def column_name(_); end

  def columns(); end

  def database_name(_); end

  def done?(); end

  def each(&blk); end

  def execute(*bind_vars); end

  def execute!(*bind_vars, &block); end

  def initialize(_, _1); end

  def must_be_open!(); end

  def remainder(); end

  def reset!(); end

  def step(); end

  def types(); end
end

class SQLite3::Statement
end

class SQLite3::TooBigException
end

class SQLite3::TooBigException
end

class SQLite3::Translator
  def add_translator(type, &block); end

  def translate(type, value); end
end

class SQLite3::Translator
end

class SQLite3::UnsupportedException
end

class SQLite3::UnsupportedException
end

class SQLite3::Value
  def handle(); end

  def initialize(db, handle); end

  def length(utf16=T.unsafe(nil)); end

  def null?(); end

  def to_blob(); end

  def to_f(); end

  def to_i(); end

  def to_int64(); end

  def to_s(utf16=T.unsafe(nil)); end

  def type(); end
end

class SQLite3::Value
end

module SQLite3::VersionProxy
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module SQLite3::VersionProxy
end

module SQLite3
  def self.const_missing(name); end

  def self.libversion(); end

  def self.sqlcipher?(); end

  def self.threadsafe(); end

  def self.threadsafe?(); end
end

ScanError = StringScanner::Error

module SecureRandom
  def self.bytes(n); end
end

module Sequel
  include ::Sequel::SQL::Constants
  ADAPTER_MAP = ::T.let(nil, ::T.untyped)
  DATABASES = ::T.let(nil, ::T.untyped)
  DEFAULT_INFLECTIONS_PROC = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
  SHARED_ADAPTER_MAP = ::T.let(nil, ::T.untyped)
  SPLIT_SYMBOL_CACHE = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_NUMBER = ::T.let(nil, ::T.untyped)
  VIRTUAL_ROW = ::T.let(nil, ::T.untyped)
end

class Sequel::ASTTransformer
  def transform(obj); end
end

class Sequel::ASTTransformer
end

class Sequel::AdapterNotFound
end

class Sequel::AdapterNotFound
end

class Sequel::BasicObject
end

class Sequel::BasicObject
  def self.const_missing(name); end
end

class Sequel::CheckConstraintViolation
end

class Sequel::CheckConstraintViolation
end

class Sequel::ConnectionPool
  def after_connect(); end

  def after_connect=(after_connect); end

  def connect_sqls(); end

  def connect_sqls=(connect_sqls); end

  def db(); end

  def db=(db); end

  def initialize(db, opts=T.unsafe(nil)); end

  def servers(); end
  OPTS = ::T.let(nil, ::T.untyped)
  POOL_CLASS_MAP = ::T.let(nil, ::T.untyped)
end

module Sequel::ConnectionPool::ClassMethods
  def get_pool(db, opts=T.unsafe(nil)); end
end

module Sequel::ConnectionPool::ClassMethods
end

class Sequel::ConnectionPool
  extend ::Sequel::ConnectionPool::ClassMethods
end

class Sequel::ConstraintViolation
end

class Sequel::ConstraintViolation
end

class Sequel::Database
  def <<(sql); end

  def [](*args); end

  def adapter_scheme(); end

  def add_column(table, *args); end

  def add_index(table, columns, options=T.unsafe(nil)); end

  def add_servers(servers); end

  def after_commit(opts=T.unsafe(nil), &block); end

  def after_rollback(opts=T.unsafe(nil), &block); end

  def alter_table(name, &block); end

  def alter_table_generator(&block); end

  def cache_schema(); end

  def cache_schema=(cache_schema); end

  def call(ps_name, hash=T.unsafe(nil), &block); end

  def cast_type_literal(type); end

  def create_join_table(hash, options=T.unsafe(nil)); end

  def create_join_table!(hash, options=T.unsafe(nil)); end

  def create_join_table?(hash, options=T.unsafe(nil)); end

  def create_or_replace_view(name, source, options=T.unsafe(nil)); end

  def create_table(name, options=T.unsafe(nil), &block); end

  def create_table!(name, options=T.unsafe(nil), &block); end

  def create_table?(name, options=T.unsafe(nil), &block); end

  def create_table_generator(&block); end

  def create_view(name, source, options=T.unsafe(nil)); end

  def database_type(); end

  def dataset(); end

  def dataset_class(); end

  def dataset_class=(c); end

  def default_string_column_size(); end

  def default_string_column_size=(default_string_column_size); end

  def disconnect(opts=T.unsafe(nil)); end

  def disconnect_connection(conn); end

  def drop_column(table, *args); end

  def drop_index(table, columns, options=T.unsafe(nil)); end

  def drop_join_table(hash, options=T.unsafe(nil)); end

  def drop_table(*names); end

  def drop_table?(*names); end

  def drop_view(*names); end

  def execute_ddl(sql, opts=T.unsafe(nil), &block); end

  def execute_dui(sql, opts=T.unsafe(nil), &block); end

  def execute_insert(sql, opts=T.unsafe(nil), &block); end

  def extend_datasets(mod=T.unsafe(nil), &block); end

  def extension(*exts); end

  def fetch(sql, *args, &block); end

  def from(*args, &block); end

  def from_application_timestamp(v); end

  def get(*args, &block); end

  def global_index_namespace?(); end

  def in_transaction?(opts=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def literal(v); end

  def literal_symbol(sym); end

  def literal_symbol_set(sym, lit); end

  def log_connection_info(); end

  def log_connection_info=(log_connection_info); end

  def log_connection_yield(sql, conn, args=T.unsafe(nil)); end

  def log_exception(exception, message); end

  def log_info(message, args=T.unsafe(nil)); end

  def log_warn_duration(); end

  def log_warn_duration=(log_warn_duration); end

  def logger=(logger); end

  def loggers(); end

  def loggers=(loggers); end

  def opts(); end

  def pool(); end

  def prepared_statement(name); end

  def prepared_statements(); end

  def quote_identifier(v); end

  def remove_servers(*servers); end

  def rename_column(table, *args); end

  def rename_table(name, new_name); end

  def rollback_checker(opts=T.unsafe(nil)); end

  def rollback_on_exit(opts=T.unsafe(nil)); end

  def run(sql, opts=T.unsafe(nil)); end

  def schema(table, opts=T.unsafe(nil)); end

  def schema_type_class(type); end

  def select(*args, &block); end

  def serial_primary_key_options(); end

  def servers(); end

  def set_column_default(table, *args); end

  def set_column_type(table, *args); end

  def set_prepared_statement(name, ps); end

  def sharded?(); end

  def single_threaded?(); end

  def sql_log_level(); end

  def sql_log_level=(sql_log_level); end

  def supports_create_table_if_not_exists?(); end

  def supports_deferrable_constraints?(); end

  def supports_deferrable_foreign_key_constraints?(); end

  def supports_drop_table_if_exists?(); end

  def supports_foreign_key_parsing?(); end

  def supports_index_parsing?(); end

  def supports_partial_indexes?(); end

  def supports_prepared_transactions?(); end

  def supports_savepoints?(); end

  def supports_savepoints_in_prepared_transactions?(); end

  def supports_schema_parsing?(); end

  def supports_table_listing?(); end

  def supports_transaction_isolation_levels?(); end

  def supports_transactional_ddl?(); end

  def supports_view_listing?(); end

  def supports_views_with_check_option?(); end

  def supports_views_with_local_check_option?(); end

  def synchronize(server=T.unsafe(nil), &block); end

  def table_exists?(name); end

  def test_connection(server=T.unsafe(nil)); end

  def timezone(); end

  def timezone=(timezone); end

  def to_application_timestamp(v); end

  def transaction(opts=T.unsafe(nil), &block); end

  def transaction_isolation_level(); end

  def transaction_isolation_level=(transaction_isolation_level); end

  def typecast_value(column_type, value); end

  def uri(); end

  def url(); end

  def valid_connection?(conn); end
  ADAPTERS = ::T.let(nil, ::T.untyped)
  CHECK_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  COLUMN_DEFINITION_ORDER = ::T.let(nil, ::T.untyped)
  COLUMN_SCHEMA_DATETIME_TYPES = ::T.let(nil, ::T.untyped)
  COLUMN_SCHEMA_STRING_TYPES = ::T.let(nil, ::T.untyped)
  COMBINABLE_ALTER_TABLE_OPS = ::T.let(nil, ::T.untyped)
  DEFAULT_DATABASE_ERROR_REGEXPS = ::T.let(nil, ::T.untyped)
  DEFAULT_STRING_COLUMN_SIZE = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  NOT_NULL_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
  SCHEMA_TYPE_CLASSES = ::T.let(nil, ::T.untyped)
  SERIALIZATION_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
  TRANSACTION_ISOLATION_LEVELS = ::T.let(nil, ::T.untyped)
  UNIQUE_CONSTRAINT_SQLSTATES = ::T.let(nil, ::T.untyped)
end

class Sequel::Database
  def self.adapter_class(scheme); end

  def self.adapter_scheme(); end

  def self.after_initialize(&block); end

  def self.connect(conn_string, opts=T.unsafe(nil)); end

  def self.extension(*extensions); end

  def self.load_adapter(scheme, opts=T.unsafe(nil)); end

  def self.register_extension(ext, mod=T.unsafe(nil), &block); end

  def self.run_after_initialize(instance); end

  def self.set_shared_adapter_scheme(scheme, mod); end
end

class Sequel::DatabaseConnectionError
end

class Sequel::DatabaseConnectionError
end

class Sequel::DatabaseDisconnectError
end

class Sequel::DatabaseDisconnectError
end

class Sequel::DatabaseError
end

class Sequel::DatabaseError
end

class Sequel::DatabaseLockTimeout
end

class Sequel::DatabaseLockTimeout
end

class Sequel::Dataset
  include ::Enumerable
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::StringMethods
  def <<(arg); end

  def ==(o); end

  def [](*conditions); end

  def _columns(); end

  def _import(columns, values, opts); end

  def _select_map_multiple(ret_cols); end

  def _select_map_single(); end

  def add_graph_aliases(graph_aliases); end

  def aliased_expression_sql_append(sql, ae); end

  def all(&block); end

  def array_sql_append(sql, a); end

  def as_hash(key_column, value_column=T.unsafe(nil), opts=T.unsafe(nil)); end

  def avg(arg=T.unsafe(nil), &block); end

  def bind(bind_vars=T.unsafe(nil)); end

  def boolean_constant_sql_append(sql, constant); end

  def cache(); end

  def cache_get(k); end

  def cache_set(k, v); end

  def call(type, bind_variables=T.unsafe(nil), *values, &block); end

  def case_expression_sql_append(sql, ce); end

  def cast_sql_append(sql, expr, type); end

  def clear_columns_cache(); end

  def clone(opts=T.unsafe(nil)); end

  def column_all_sql_append(sql, ca); end

  def columns(); end

  def columns!(); end

  def complex_expression_sql_append(sql, op, args); end

  def compound_clone(type, dataset, opts); end

  def compound_from_self(); end

  def constant_sql_append(sql, constant); end

  def count(arg=T.unsafe(nil), &block); end

  def cross_join(table, opts=T.unsafe(nil)); end

  def current_datetime(); end

  def db(); end

  def delayed_evaluation_sql_append(sql, delay); end

  def delete(&block); end

  def delete_sql(); end

  def distinct(*args, &block); end

  def each(&blk); end

  def each_server(); end

  def empty?(); end

  def eql?(o); end

  def escape_like(string); end

  def except(dataset, opts=T.unsafe(nil)); end

  def exclude(*cond, &block); end

  def exclude_having(*cond, &block); end

  def exists(); end

  def extension(*a); end

  def filter(*cond, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def first_source(); end

  def first_source_alias(); end

  def first_source_table(); end

  def for_update(); end

  def from(*source, &block); end

  def from_self(opts=T.unsafe(nil)); end

  def full_join(*args, &block); end

  def full_outer_join(*args, &block); end

  def function_sql_append(sql, f); end

  def get(column=T.unsafe(nil), &block); end

  def graph(dataset, join_conditions=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def grep(columns, patterns, opts=T.unsafe(nil)); end

  def group(*columns, &block); end

  def group_and_count(*columns, &block); end

  def group_append(*columns, &block); end

  def group_by(*columns, &block); end

  def group_cube(); end

  def group_rollup(); end

  def grouping_sets(); end

  def having(*cond, &block); end

  def import(columns, values, opts=T.unsafe(nil)); end

  def initialize(db); end

  def inner_join(*args, &block); end

  def insert(*values, &block); end

  def insert_sql(*values); end

  def intersect(dataset, opts=T.unsafe(nil)); end

  def invert(); end

  def join(*args, &block); end

  def join_clause_sql_append(sql, jc); end

  def join_on_clause_sql_append(sql, jc); end

  def join_table(type, table, expr=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def join_using_clause_sql_append(sql, jc); end

  def joined_dataset?(); end

  def last(*args, &block); end

  def lateral(); end

  def left_join(*args, &block); end

  def left_outer_join(*args, &block); end

  def limit(l, o=T.unsafe(nil)); end

  def literal(*args, &block); end

  def literal_append(sql, v); end

  def lock_style(style); end

  def map(column=T.unsafe(nil), &block); end

  def max(arg=T.unsafe(nil), &block); end

  def min(arg=T.unsafe(nil), &block); end

  def multi_insert(hashes, opts=T.unsafe(nil)); end

  def multi_insert_sql(columns, values); end

  def naked(); end

  def natural_full_join(table, opts=T.unsafe(nil)); end

  def natural_join(table, opts=T.unsafe(nil)); end

  def natural_left_join(table, opts=T.unsafe(nil)); end

  def natural_right_join(table, opts=T.unsafe(nil)); end

  def negative_boolean_constant_sql_append(sql, constant); end

  def nowait(); end

  def offset(o); end

  def options_overlap(opts); end

  def opts(); end

  def or(*cond, &block); end

  def order(*columns, &block); end

  def order_append(*columns, &block); end

  def order_by(*columns, &block); end

  def order_more(*columns, &block); end

  def order_prepend(*columns, &block); end

  def ordered_expression_sql_append(sql, oe); end

  def paged_each(opts=T.unsafe(nil)); end

  def placeholder_literal_string_sql_append(sql, pls); end

  def prepare(type, name, *values); end

  def provides_accurate_rows_matched?(); end

  def qualified_identifier_sql_append(sql, table, column=T.unsafe(nil)); end

  def qualify(table=T.unsafe(nil)); end

  def quote_identifier(*args, &block); end

  def quote_identifier_append(sql, name); end

  def quote_identifiers?(); end

  def quote_schema_table(*args, &block); end

  def quote_schema_table_append(sql, table); end

  def quoted_identifier_append(sql, name); end

  def recursive_cte_requires_column_aliases?(); end

  def requires_placeholder_type_specifiers?(); end

  def requires_sql_standard_datetimes?(); end

  def returning(*values); end

  def reverse(*order, &block); end

  def reverse_order(*order, &block); end

  def right_join(*args, &block); end

  def right_outer_join(*args, &block); end

  def row_number_column(); end

  def row_proc(); end

  def schema_and_table(table_name, sch=T.unsafe(nil)); end

  def select(*columns, &block); end

  def select_all(*tables); end

  def select_append(*columns, &block); end

  def select_group(*columns, &block); end

  def select_hash(key_column, value_column, opts=T.unsafe(nil)); end

  def select_hash_groups(key_column, value_column, opts=T.unsafe(nil)); end

  def select_map(column=T.unsafe(nil), &block); end

  def select_more(*columns, &block); end

  def select_order_map(column=T.unsafe(nil), &block); end

  def select_sql(); end

  def server(servr); end

  def server?(server); end

  def set_graph_aliases(graph_aliases); end

  def simple_select_all?(); end

  def single_record(); end

  def single_record!(); end

  def single_value(); end

  def single_value!(); end

  def single_value_ds(); end

  def skip_limit_check(); end

  def skip_locked(); end

  def split_alias(c); end

  def split_qualifiers(table_name, *args); end

  def sql(); end

  def subscript_sql_append(sql, s); end

  def sum(arg=T.unsafe(nil), &block); end

  def supports_cte?(type=T.unsafe(nil)); end

  def supports_cte_in_subqueries?(); end

  def supports_derived_column_lists?(); end

  def supports_distinct_on?(); end

  def supports_group_cube?(); end

  def supports_group_rollup?(); end

  def supports_grouping_sets?(); end

  def supports_insert_select?(); end

  def supports_intersect_except?(); end

  def supports_intersect_except_all?(); end

  def supports_is_true?(); end

  def supports_join_using?(); end

  def supports_lateral_subqueries?(); end

  def supports_limits_in_correlated_subqueries?(); end

  def supports_modifying_joins?(); end

  def supports_multiple_column_in?(); end

  def supports_nowait?(); end

  def supports_offsets_in_correlated_subqueries?(); end

  def supports_ordered_distinct_on?(); end

  def supports_regexp?(); end

  def supports_replace?(); end

  def supports_returning?(type); end

  def supports_select_all_and_column?(); end

  def supports_skip_locked?(); end

  def supports_timestamp_timezones?(); end

  def supports_timestamp_usecs?(); end

  def supports_where_true?(); end

  def supports_window_clause?(); end

  def supports_window_function_frame_option?(option); end

  def supports_window_functions?(); end

  def to_hash(*a); end

  def to_hash_groups(key_column, value_column=T.unsafe(nil), opts=T.unsafe(nil)); end

  def to_prepared_statement(type, values=T.unsafe(nil), opts=T.unsafe(nil)); end

  def truncate(); end

  def truncate_sql(); end

  def unfiltered(); end

  def ungraphed(); end

  def ungrouped(); end

  def union(dataset, opts=T.unsafe(nil)); end

  def unlimited(); end

  def unordered(); end

  def unqualified_column_for(v); end

  def unused_table_alias(table_alias, used_aliases=T.unsafe(nil)); end

  def update(values=T.unsafe(nil), &block); end

  def update_sql(values=T.unsafe(nil)); end

  def where(*cond, &block); end

  def where_all(cond, &block); end

  def where_each(cond, &block); end

  def where_single_value(cond); end

  def window(name, opts); end

  def window_sql_append(sql, opts); end

  def with(name, dataset, opts=T.unsafe(nil)); end

  def with_extend(*mods, &block); end

  def with_quote_identifiers(v); end

  def with_recursive(name, nonrecursive, recursive, opts=T.unsafe(nil)); end

  def with_row_proc(callable); end

  def with_sql(sql, *args); end

  def with_sql_all(sql, &block); end

  def with_sql_delete(sql); end

  def with_sql_each(sql); end

  def with_sql_first(sql); end

  def with_sql_insert(sql); end

  def with_sql_single_value(sql); end

  def with_sql_update(sql); end
  ACTION_METHODS = ::T.let(nil, ::T.untyped)
  BITWISE_METHOD_MAP = ::T.let(nil, ::T.untyped)
  COLUMNS_CLONE_OPTIONS = ::T.let(nil, ::T.untyped)
  COLUMN_CHANGE_OPTS = ::T.let(nil, ::T.untyped)
  CONDITIONED_JOIN_TYPES = ::T.let(nil, ::T.untyped)
  COUNT_FROM_SELF_OPTS = ::T.let(nil, ::T.untyped)
  COUNT_OF_ALL_AS_COUNT = ::T.let(nil, ::T.untyped)
  COUNT_SELECT = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  DEFAULT_PREPARED_STATEMENT_MODULE_METHODS = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_SELECT = ::T.let(nil, ::T.untyped)
  EXISTS = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  IS_LITERALS = ::T.let(nil, ::T.untyped)
  IS_OPERATORS = ::T.let(nil, ::T.untyped)
  JOIN_METHODS = ::T.let(nil, ::T.untyped)
  LIKE_OPERATORS = ::T.let(nil, ::T.untyped)
  NON_SQL_OPTIONS = ::T.let(nil, ::T.untyped)
  N_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
  PREPARED_ARG_PLACEHOLDER = ::T.let(nil, ::T.untyped)
  PREPARED_STATEMENT_MODULE_CODE = ::T.let(nil, ::T.untyped)
  QUALIFY_KEYS = ::T.let(nil, ::T.untyped)
  QUERY_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_OPERATORS = ::T.let(nil, ::T.untyped)
  SIMPLE_SELECT_ALL_ALLOWED_FROM = ::T.let(nil, ::T.untyped)
  TRUE_FREEZE = ::T.let(nil, ::T.untyped)
  TWO_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
  UNCONDITIONED_JOIN_TYPES = ::T.let(nil, ::T.untyped)
  WILDCARD = ::T.let(nil, ::T.untyped)
end

module Sequel::Dataset::ArgumentMapper
  def bind_arguments(); end

  def call(bind_vars=T.unsafe(nil), &block); end

  def prepared_sql(); end

  def prepared_statement_name(); end
end

module Sequel::Dataset::ArgumentMapper
end

class Sequel::Dataset::DatasetModule
  def distinct(name, *args, &block); end

  def exclude(name, *args, &block); end

  def exclude_having(name, *args, &block); end

  def grep(name, *args, &block); end

  def group(name, *args, &block); end

  def group_and_count(name, *args, &block); end

  def group_append(name, *args, &block); end

  def having(name, *args, &block); end

  def limit(name, *args, &block); end

  def offset(name, *args, &block); end

  def order(name, *args, &block); end

  def order_append(name, *args, &block); end

  def order_prepend(name, *args, &block); end

  def reverse(name, *args, &block); end

  def select(name, *args, &block); end

  def select_all(name, *args, &block); end

  def select_append(name, *args, &block); end

  def select_group(name, *args, &block); end

  def server(name, *args, &block); end

  def where(name, *args, &block); end
end

class Sequel::Dataset::DatasetModule
  def self.def_dataset_caching_method(mod, meth); end
end

module Sequel::Dataset::EmulatePreparedStatementMethods
  include ::Sequel::Dataset::UnnumberedArgumentMapper
  include ::Sequel::Dataset::ArgumentMapper
  def run(&block); end
end

module Sequel::Dataset::EmulatePreparedStatementMethods
end

class Sequel::Dataset::PlaceholderLiteralizer
  def all(*args, &block); end

  def each(*args, &block); end

  def first(*args); end

  def get(*args); end

  def initialize(dataset, fragments, final_sql, arity); end

  def sql(*args); end

  def with_dataset(); end
end

class Sequel::Dataset::PlaceholderLiteralizer::Argument
  def initialize(recorder, pos, transformer=T.unsafe(nil)); end

  def sql_literal_append(ds, sql); end

  def transform(&block); end
end

class Sequel::Dataset::PlaceholderLiteralizer::Argument
end

class Sequel::Dataset::PlaceholderLiteralizer::Recorder
  def arg(v=T.unsafe(nil)); end

  def loader(dataset, &block); end

  def use(sql, arg, transformer); end
end

class Sequel::Dataset::PlaceholderLiteralizer::Recorder
end

class Sequel::Dataset::PlaceholderLiteralizer
  def self.loader(dataset, &block); end
end

module Sequel::Dataset::PreparedStatementMethods
  def call(bind_vars=T.unsafe(nil), &block); end

  def columns(); end

  def delayed_evaluation_sql_append(sql, delay); end

  def inspect(); end

  def literal_symbol_append(sql, v); end

  def log_sql(); end

  def orig_dataset(); end

  def prepare(*_); end

  def prepared_args(); end

  def prepared_modify_values(); end

  def prepared_sql(); end

  def prepared_type(); end

  def run(&block); end
end

module Sequel::Dataset::PreparedStatementMethods
end

module Sequel::Dataset::UnnumberedArgumentMapper
  include ::Sequel::Dataset::ArgumentMapper
  def map_to_prepared_args(bind_vars); end
end

module Sequel::Dataset::UnnumberedArgumentMapper
end

class Sequel::Dataset
  def self.clause_methods(type, clauses); end

  def self.def_sql_method(mod, type, clauses); end

  def self.register_extension(ext, mod=T.unsafe(nil), &block); end
end

module Sequel::Deprecation
end

module Sequel::Deprecation
  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.deprecate(method, instead=T.unsafe(nil)); end

  def self.deprecate_constant(mod, constant); end

  def self.output(); end

  def self.output=(output); end

  def self.prefix(); end

  def self.prefix=(prefix); end
end

class Sequel::Error
  def wrapped_exception(); end

  def wrapped_exception=(wrapped_exception); end
end

class Sequel::Error
end

class Sequel::ForeignKeyConstraintViolation
end

class Sequel::ForeignKeyConstraintViolation
end

class Sequel::HookFailed
  def initialize(message=T.unsafe(nil), model=T.unsafe(nil)); end

  def model(); end
end

class Sequel::HookFailed
end

module Sequel::Inflections
end

module Sequel::Inflections
  def self.clear(scope=T.unsafe(nil)); end

  def self.irregular(singular, plural); end

  def self.plural(rule, replacement); end

  def self.plurals(); end

  def self.singular(rule, replacement); end

  def self.singulars(); end

  def self.uncountable(*words); end

  def self.uncountables(); end
end

class Sequel::InvalidOperation
end

class Sequel::InvalidOperation
end

class Sequel::InvalidValue
end

class Sequel::InvalidValue
end

class Sequel::LiteralString
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::CastMethods
  def lit(*args); end

  def to_sequel_blob(); end
end

class Sequel::LiteralString
end

class Sequel::MassAssignmentRestriction
end

class Sequel::MassAssignmentRestriction
end

class Sequel::Model
  include ::Sequel::Model::InstanceMethods
  include ::Sequel::Model::Associations::InstanceMethods
  HOOKS = ::T.let(nil, ::T.untyped)
  OPTS = ::T.let(nil, ::T.untyped)
  RESTRICTED_SETTER_METHODS = ::T.let(nil, ::T.untyped)
end

module Sequel::Model::Associations
  ASSOCIATION_TYPES = ::T.let(nil, ::T.untyped)
end

module Sequel::Model::Associations::AssociationDatasetMethods
  def association_reflection(); end

  def model_object(); end
end

module Sequel::Model::Associations::AssociationDatasetMethods
end

class Sequel::Model::Associations::AssociationReflection
  include ::Sequel::Inflections
  def _add_method(); end

  def _remove_all_method(); end

  def _remove_method(); end

  def _setter_method(); end

  def add_method(); end

  def apply_dataset_changes(ds); end

  def apply_distinct_on_eager_limit_strategy(ds); end

  def apply_eager_dataset_changes(ds); end

  def apply_eager_graph_limit_strategy(strategy, ds); end

  def apply_eager_limit_strategy(ds, strategy=T.unsafe(nil), limit_and_offset=T.unsafe(nil)); end

  def apply_ruby_eager_limit_strategy(rows, limit_and_offset=T.unsafe(nil)); end

  def apply_window_function_eager_limit_strategy(ds, limit_and_offset=T.unsafe(nil)); end

  def assign_singular?(); end

  def associated_class(); end

  def associated_dataset(); end

  def association_dataset_for(object); end

  def association_dataset_proc(); end

  def association_method(); end

  def can_have_associated_objects?(obj); end

  def cloneable?(ref); end

  def dataset_method(); end

  def dataset_need_primary_key?(); end

  def delete_row_number_column(ds=T.unsafe(nil)); end

  def eager_graph_lazy_dataset?(); end

  def eager_graph_limit_strategy(strategy); end

  def eager_limit_strategy(); end

  def eager_load_results(eo, &block); end

  def eager_loader_key(); end

  def eager_loading_use_associated_key?(); end

  def filter_by_associations_add_conditions?(); end

  def filter_by_associations_conditions_expression(obj); end

  def finalize(); end

  def finalize_settings(); end

  def handle_silent_modification_failure?(); end

  def initialize_association_cache(objects); end

  def limit_and_offset(); end

  def need_associated_primary_key?(); end

  def placeholder_loader(); end

  def predicate_key_values(object); end

  def predicate_keys(); end

  def qualify(table, col); end

  def qualify_assoc(col); end

  def qualify_cur(col); end

  def reciprocal(); end

  def reciprocal_array?(); end

  def remove_all_method(); end

  def remove_before_destroy?(); end

  def remove_method(); end

  def remove_should_check_existing?(); end

  def returns_array?(); end

  def set_reciprocal_to_self?(); end

  def setter_method(); end

  def slice_range(limit_and_offset=T.unsafe(nil)); end
  ASSOCIATION_DATASET_PROC = ::T.let(nil, ::T.untyped)
  FINALIZE_SETTINGS = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Associations::AssociationReflection
end

module Sequel::Model::Associations::ClassMethods
  def all_association_reflections(); end

  def associate(type, name, opts=T.unsafe(nil), &block); end

  def association_full_join(*args, &block); end

  def association_inner_join(*args, &block); end

  def association_join(*args, &block); end

  def association_left_join(*args, &block); end

  def association_reflection(name); end

  def association_reflections(); end

  def association_right_join(*args, &block); end

  def associations(); end

  def autoreloading_associations(); end

  def cache_associations(); end

  def cache_associations=(cache_associations); end

  def default_association_options(); end

  def default_association_options=(default_association_options); end

  def default_association_type_options(); end

  def default_association_type_options=(default_association_type_options); end

  def default_eager_limit_strategy(); end

  def default_eager_limit_strategy=(default_eager_limit_strategy); end

  def eager(*args, &block); end

  def eager_graph(*args, &block); end

  def eager_graph_with_options(*args, &block); end

  def eager_load_results(opts, eo, &block); end

  def finalize_associations(); end

  def freeze(); end

  def inherited_instance_variables(); end

  def many_to_many(name, opts=T.unsafe(nil), &block); end

  def many_to_one(name, opts=T.unsafe(nil), &block); end

  def one_through_one(name, opts=T.unsafe(nil), &block); end

  def one_to_many(name, opts=T.unsafe(nil), &block); end

  def one_to_one(name, opts=T.unsafe(nil), &block); end
end

module Sequel::Model::Associations::ClassMethods
end

module Sequel::Model::Associations::DatasetMethods
  def as_hash(key_column=T.unsafe(nil), value_column=T.unsafe(nil), opts=T.unsafe(nil)); end

  def association_full_join(*associations); end

  def association_inner_join(*associations); end

  def association_join(*associations); end

  def association_left_join(*associations); end

  def association_right_join(*associations); end

  def complex_expression_sql_append(sql, op, args); end

  def eager(*associations); end

  def eager_graph(*associations); end

  def eager_graph_association(ds, model, ta, requirements, r, *associations); end

  def eager_graph_associations(ds, model, ta, requirements, *associations); end

  def eager_graph_build_associations(hashes); end

  def eager_graph_with_options(associations, opts=T.unsafe(nil)); end

  def to_hash_groups(key_column, value_column=T.unsafe(nil), opts=T.unsafe(nil)); end

  def ungraphed(); end
end

module Sequel::Model::Associations::DatasetMethods
end

class Sequel::Model::Associations::DatasetModule
  def eager(name, *args, &block); end
end

class Sequel::Model::Associations::DatasetModule
end

class Sequel::Model::Associations::EagerGraphLoader
  def after_load_map(); end

  def alias_map(); end

  def column_maps(); end

  def dependency_map(); end

  def initialize(dataset); end

  def limit_map(); end

  def load(hashes); end

  def master(); end

  def primary_keys(); end

  def reciprocal_map(); end

  def records_map(); end

  def reflection_map(); end

  def row_procs(); end

  def type_map(); end
end

class Sequel::Model::Associations::EagerGraphLoader
end

module Sequel::Model::Associations::InstanceMethods
  def associations(); end

  def freeze(); end
end

module Sequel::Model::Associations::InstanceMethods
end

class Sequel::Model::Associations::ManyToManyAssociationReflection
  def associated_key_alias(); end

  def associated_key_array(); end

  def associated_key_column(); end

  def associated_key_table(); end

  def associated_object_keys(); end

  def default_associated_key_alias(); end

  def default_eager_loader(eo); end

  def default_join_table(); end

  def default_left_key(); end

  def default_right_key(); end

  def join_table_alias(); end

  def join_table_source(); end

  def predicate_key(); end

  def qualified_left_key(); end

  def qualified_right_key(); end

  def qualified_right_primary_key(); end

  def right_primary_key(); end

  def right_primary_key_method(); end

  def right_primary_key_methods(); end

  def right_primary_keys(); end
  FINALIZE_SETTINGS = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Associations::ManyToManyAssociationReflection
end

class Sequel::Model::Associations::ManyToOneAssociationReflection
  def associated_object_keys(); end

  def default_key(); end

  def eager_graph_limit_strategy(_); end

  def predicate_key(); end

  def primary_key(); end

  def primary_key_method(); end

  def primary_key_methods(); end

  def primary_keys(); end

  def qualified_primary_key(); end
  FINALIZE_SETTINGS = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Associations::ManyToOneAssociationReflection
end

class Sequel::Model::Associations::OneThroughOneAssociationReflection
  include ::Sequel::Model::Associations::SingularAssociationReflection
end

class Sequel::Model::Associations::OneThroughOneAssociationReflection
end

class Sequel::Model::Associations::OneToManyAssociationReflection
  def associated_object_keys(); end

  def default_key(); end

  def predicate_key(); end

  def primary_key(); end

  def qualified_key(); end

  def qualified_primary_key(); end
  FINALIZE_SETTINGS = ::T.let(nil, ::T.untyped)
end

class Sequel::Model::Associations::OneToManyAssociationReflection
end

class Sequel::Model::Associations::OneToOneAssociationReflection
  include ::Sequel::Model::Associations::SingularAssociationReflection
end

class Sequel::Model::Associations::OneToOneAssociationReflection
end

module Sequel::Model::Associations::SingularAssociationReflection
  def assign_singular?(); end

  def filter_by_associations_add_conditions?(); end

  def limit_and_offset(); end

  def returns_array?(); end
end

module Sequel::Model::Associations::SingularAssociationReflection
end

module Sequel::Model::Associations
  def self.apply(model); end
end

module Sequel::Model::ClassMethods
  def Model(source); end

  def [](*args); end

  def all(*args, &block); end

  def as_hash(*args, &block); end

  def avg(*args, &block); end

  def cache_anonymous_models(); end

  def cache_anonymous_models=(cache_anonymous_models); end

  def call(values); end

  def clear_setter_methods_cache(); end

  def columns(); end

  def count(*args, &block); end

  def create(values=T.unsafe(nil), &block); end

  def cross_join(*args, &block); end

  def dataset(); end

  def dataset=(ds); end

  def dataset_method_modules(); end

  def dataset_module(mod=T.unsafe(nil), &block); end

  def dataset_module_class(); end

  def db(); end

  def db=(db); end

  def db_schema(); end

  def def_Model(mod); end

  def def_column_alias(meth, column); end

  def default_set_fields_options(); end

  def default_set_fields_options=(default_set_fields_options); end

  def distinct(*args, &block); end

  def each(*args, &block); end

  def each_server(*args, &block); end

  def empty?(*args, &block); end

  def except(*args, &block); end

  def exclude(*args, &block); end

  def exclude_having(*args, &block); end

  def fast_instance_delete_sql(); end

  def fast_pk_lookup_sql(); end

  def fetch(*args, &block); end

  def fetch_rows(*args, &block); end

  def filter(*args, &block); end

  def find(*args, &block); end

  def find_or_create(cond, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def for_update(*args, &block); end

  def freeze(); end

  def from(*args, &block); end

  def from_self(*args, &block); end

  def full_join(*args, &block); end

  def full_outer_join(*args, &block); end

  def get(*args, &block); end

  def graph(*args, &block); end

  def grep(*args, &block); end

  def group(*args, &block); end

  def group_and_count(*args, &block); end

  def group_append(*args, &block); end

  def group_by(*args, &block); end

  def has_dataset?(); end

  def having(*args, &block); end

  def implicit_table_name(); end

  def import(*args, &block); end

  def include(*mods); end

  def inherited(subclass); end

  def inner_join(*args, &block); end

  def insert(*args, &block); end

  def instance_dataset(); end

  def intersect(*args, &block); end

  def invert(*args, &block); end

  def join(*args, &block); end

  def join_table(*args, &block); end

  def last(*args, &block); end

  def left_join(*args, &block); end

  def left_outer_join(*args, &block); end

  def limit(*args, &block); end

  def load(values); end

  def lock_style(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def method_added(meth); end

  def min(*args, &block); end

  def multi_insert(*args, &block); end

  def naked(*args, &block); end

  def natural_full_join(*args, &block); end

  def natural_join(*args, &block); end

  def natural_left_join(*args, &block); end

  def natural_right_join(*args, &block); end

  def no_primary_key(); end

  def offset(*args, &block); end

  def order(*args, &block); end

  def order_append(*args, &block); end

  def order_by(*args, &block); end

  def order_more(*args, &block); end

  def order_prepend(*args, &block); end

  def paged_each(*args, &block); end

  def plugin(plugin, *args, &block); end

  def plugins(); end

  def primary_key(); end

  def primary_key_hash(value); end

  def qualified_primary_key_hash(value, qualifier=T.unsafe(nil)); end

  def qualify(*args, &block); end

  def raise_on_save_failure(); end

  def raise_on_save_failure=(raise_on_save_failure); end

  def raise_on_typecast_failure(); end

  def raise_on_typecast_failure=(raise_on_typecast_failure); end

  def require_modification(); end

  def require_modification=(require_modification); end

  def require_valid_table(); end

  def require_valid_table=(require_valid_table); end

  def restrict_primary_key(); end

  def restrict_primary_key?(); end

  def reverse(*args, &block); end

  def reverse_order(*args, &block); end

  def right_join(*args, &block); end

  def right_outer_join(*args, &block); end

  def select(*args, &block); end

  def select_all(*args, &block); end

  def select_append(*args, &block); end

  def select_group(*args, &block); end

  def select_hash(*args, &block); end

  def select_hash_groups(*args, &block); end

  def select_map(*args, &block); end

  def select_more(*args, &block); end

  def select_order_map(*args, &block); end

  def server(*args, &block); end

  def set_dataset(ds, opts=T.unsafe(nil)); end

  def set_primary_key(key); end

  def setter_methods(); end

  def simple_pk(); end

  def simple_table(); end

  def single_record(*args, &block); end

  def single_record!(*args, &block); end

  def single_value(*args, &block); end

  def single_value!(*args, &block); end

  def strict_param_setting(); end

  def strict_param_setting=(strict_param_setting); end

  def sum(*args, &block); end

  def table_name(); end

  def to_hash(*args, &block); end

  def to_hash_groups(*args, &block); end

  def truncate(*args, &block); end

  def typecast_empty_string_to_nil(); end

  def typecast_empty_string_to_nil=(typecast_empty_string_to_nil); end

  def typecast_on_assignment(); end

  def typecast_on_assignment=(typecast_on_assignment); end

  def unfiltered(*args, &block); end

  def ungraphed(*args, &block); end

  def ungrouped(*args, &block); end

  def union(*args, &block); end

  def unlimited(*args, &block); end

  def unordered(*args, &block); end

  def unrestrict_primary_key(); end

  def use_transactions(); end

  def use_transactions=(use_transactions); end

  def where(*args, &block); end

  def where_all(*args, &block); end

  def where_each(*args, &block); end

  def where_single_value(*args, &block); end

  def with(*args, &block); end

  def with_pk(pk); end

  def with_pk!(pk); end

  def with_recursive(*args, &block); end

  def with_sql(*args, &block); end
end

module Sequel::Model::ClassMethods
end

module Sequel::Model::DatasetMethods
  def [](*args); end

  def as_hash(key_column=T.unsafe(nil), value_column=T.unsafe(nil), opts=T.unsafe(nil)); end

  def destroy(); end

  def last(*a, &block); end

  def model(); end

  def paged_each(*a, &block); end

  def to_hash(*a); end

  def with_pk(pk); end

  def with_pk!(pk); end
end

module Sequel::Model::DatasetMethods
end

class Sequel::Model::DatasetModule
  def initialize(model); end

  def subset(name, *args, &block); end
end

class Sequel::Model::DatasetModule
end

class Sequel::Model::Errors
  def add(att, msg); end

  def count(); end

  def full_messages(); end

  def on(att); end
end

class Sequel::Model::Errors
end

module Sequel::Model::InstanceMethods
  def ==(obj); end

  def ===(obj); end

  def [](column); end

  def []=(column, value); end

  def _insert_values(); end

  def after_create(); end

  def after_destroy(); end

  def after_save(); end

  def after_update(); end

  def after_validation(); end

  def around_create(); end

  def around_destroy(); end

  def around_save(); end

  def around_update(); end

  def around_validation(); end

  def autoincrementing_primary_key(); end

  def before_create(); end

  def before_destroy(); end

  def before_save(); end

  def before_update(); end

  def before_validation(); end

  def cancel_action(msg=T.unsafe(nil)); end

  def changed_columns(); end

  def columns(); end

  def db(); end

  def db_schema(); end

  def delete(); end

  def destroy(opts=T.unsafe(nil)); end

  def each(&block); end

  def eql?(obj); end

  def errors(); end

  def exists?(); end

  def extend(mod); end

  def freeze(); end

  def get_column_value(*_); end

  def hash(); end

  def id(); end

  def initialize(values=T.unsafe(nil)); end

  def inspect(); end

  def keys(); end

  def lock!(style=T.unsafe(nil)); end

  def marshallable!(); end

  def model(); end

  def modified!(column=T.unsafe(nil)); end

  def modified?(column=T.unsafe(nil)); end

  def new?(); end

  def pk(); end

  def pk_equal?(obj); end

  def pk_hash(); end

  def primary_key(); end

  def qualified_pk_hash(qualifier=T.unsafe(nil)); end

  def raise_on_save_failure(); end

  def raise_on_save_failure=(raise_on_save_failure); end

  def raise_on_typecast_failure(); end

  def raise_on_typecast_failure=(raise_on_typecast_failure); end

  def refresh(); end

  def reload(); end

  def require_modification(); end

  def require_modification=(require_modification); end

  def save(opts=T.unsafe(nil)); end

  def save_changes(opts=T.unsafe(nil)); end

  def set(hash); end

  def set_column_value(*_); end

  def set_fields(hash, fields, opts=T.unsafe(nil)); end

  def set_server(s); end

  def singleton_method_added(meth); end

  def skip_validation_on_next_save!(); end

  def strict_param_setting(); end

  def strict_param_setting=(strict_param_setting); end

  def this(); end

  def to_hash(); end

  def typecast_empty_string_to_nil(); end

  def typecast_empty_string_to_nil=(typecast_empty_string_to_nil); end

  def typecast_on_assignment(); end

  def typecast_on_assignment=(typecast_on_assignment); end

  def update(hash); end

  def update_fields(hash, fields, opts=T.unsafe(nil)); end

  def use_transactions(); end

  def use_transactions=(use_transactions); end

  def valid?(opts=T.unsafe(nil)); end

  def validate(); end

  def values(); end
end

module Sequel::Model::InstanceMethods
end

class Sequel::Model
  extend ::Enumerable
  extend ::Sequel::Inflections
  extend ::Sequel::Model::ClassMethods
  extend ::Sequel::Model::Associations::ClassMethods
end

class Sequel::NoExistingObject
end

class Sequel::NoExistingObject
end

class Sequel::NoMatchingRow
  def dataset(); end

  def dataset=(dataset); end

  def initialize(msg=T.unsafe(nil)); end
end

class Sequel::NoMatchingRow
end

class Sequel::NotNullConstraintViolation
end

class Sequel::NotNullConstraintViolation
end

module Sequel::Plugins
  SEQUEL_METHOD_NAME = ::T.let(nil, ::T.untyped)
end

module Sequel::Plugins
  def self.after_set_dataset(mod, meth); end

  def self.def_dataset_methods(mod, meths); end

  def self.def_sequel_method(model, meth, expected_arity, &block); end

  def self.inherited_instance_variables(mod, hash); end
end

class Sequel::PoolTimeout
end

class Sequel::PoolTimeout
end

class Sequel::Qualifier
  def initialize(table); end
end

class Sequel::Qualifier
end

class Sequel::Rollback
end

class Sequel::Rollback
end

module Sequel::SQL
end

module Sequel::SQL::AliasMethods
  def as(aliaz, columns=T.unsafe(nil)); end
end

module Sequel::SQL::AliasMethods
end

class Sequel::SQL::AliasedExpression
  def alias(); end

  def columns(); end

  def expression(); end

  def initialize(expression, aliaz, columns=T.unsafe(nil)); end

  def to_s_append(ds, sql); end
end

class Sequel::SQL::AliasedExpression
end

module Sequel::SQL::BitwiseMethods
  def %(o); end

  def &(o); end

  def <<(o); end

  def >>(o); end

  def ^(o); end

  def |(o); end

  def ~(); end
end

module Sequel::SQL::BitwiseMethods
end

class Sequel::SQL::Blob
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::CastMethods
  def lit(*args); end

  def to_sequel_blob(); end
end

class Sequel::SQL::Blob
  def self.call(*_); end
end

class Sequel::SQL::BooleanConstant
end

class Sequel::SQL::BooleanConstant
end

class Sequel::SQL::BooleanExpression
  include ::Sequel::SQL::BooleanMethods
  def &(ce); end

  def |(ce); end
end

class Sequel::SQL::BooleanExpression
  def self.from_value_pairs(pairs, op=T.unsafe(nil), negate=T.unsafe(nil)); end

  def self.invert(ce); end
end

module Sequel::SQL::BooleanMethods
  def &(o); end

  def |(o); end

  def ~(); end
end

module Sequel::SQL::BooleanMethods
end

module Sequel::SQL::Builders
  def as(exp, aliaz, columns=T.unsafe(nil)); end

  def asc(arg, opts=T.unsafe(nil)); end

  def blob(s); end

  def case(*args); end

  def cast(arg, sql_type); end

  def cast_numeric(arg, sql_type=T.unsafe(nil)); end

  def cast_string(arg, sql_type=T.unsafe(nil)); end

  def char_length(arg); end

  def deep_qualify(qualifier, expr); end

  def delay(&block); end

  def desc(arg, opts=T.unsafe(nil)); end

  def expr(arg=T.unsafe(nil), &block); end

  def extract(datetime_part, exp); end

  def function(name, *args); end

  def identifier(name); end

  def ilike(*args); end

  def join(args, joiner=T.unsafe(nil)); end

  def like(*args); end

  def lit(s, *args); end

  def negate(arg); end

  def or(arg); end

  def qualify(qualifier, identifier); end

  def subscript(exp, *subs); end

  def trim(arg); end

  def value_list(arg); end
end

module Sequel::SQL::Builders
end

class Sequel::SQL::CaseExpression
  def conditions(); end

  def default(); end

  def expression(); end

  def expression?(); end

  def initialize(conditions, default, expression=T.unsafe(nil)); end

  def to_s_append(ds, sql); end

  def with_merged_expression(); end
end

class Sequel::SQL::CaseExpression
end

class Sequel::SQL::Cast
  def expr(); end

  def initialize(expr, type); end

  def to_s_append(ds, sql); end

  def type(); end
end

class Sequel::SQL::Cast
end

module Sequel::SQL::CastMethods
  def cast(sql_type); end

  def cast_numeric(sql_type=T.unsafe(nil)); end

  def cast_string(sql_type=T.unsafe(nil)); end
end

module Sequel::SQL::CastMethods
end

class Sequel::SQL::ColumnAll
  def initialize(table); end

  def table(); end

  def to_s_append(ds, sql); end
end

class Sequel::SQL::ColumnAll
end

class Sequel::SQL::ComplexExpression
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::PatternMatchMethods
  include ::Sequel::SQL::SubscriptMethods
  def args(); end

  def initialize(op, *args); end

  def op(); end

  def sql_boolean(); end

  def sql_number(); end

  def sql_string(); end

  def to_s_append(ds, sql); end
  ASSOCIATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  BITWISE_OPERATORS = ::T.let(nil, ::T.untyped)
  BOOLEAN_OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
  CONSTANT_INVERSIONS = ::T.let(nil, ::T.untyped)
  CUSTOM_EXPRESSIONS = ::T.let(nil, ::T.untyped)
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  INEQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  IN_OPERATORS = ::T.let(nil, ::T.untyped)
  IS_OPERATORS = ::T.let(nil, ::T.untyped)
  LIKE_OPERATORS = ::T.let(nil, ::T.untyped)
  MATHEMATICAL_OPERATORS = ::T.let(nil, ::T.untyped)
  N_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
  ONE_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
  OPERTATOR_INVERSIONS = ::T.let(nil, ::T.untyped)
  REGEXP_OPERATORS = ::T.let(nil, ::T.untyped)
  TWO_ARITY_OPERATORS = ::T.let(nil, ::T.untyped)
end

class Sequel::SQL::ComplexExpression
end

module Sequel::SQL::ComplexExpressionMethods
  def extract(datetime_part); end

  def sql_boolean(); end

  def sql_number(); end

  def sql_string(); end
end

module Sequel::SQL::ComplexExpressionMethods
end

class Sequel::SQL::Constant
  def constant(); end

  def initialize(constant); end

  def to_s_append(ds, sql); end
end

class Sequel::SQL::Constant
end

module Sequel::SQL::Constants
  CURRENT_DATE = ::T.let(nil, ::T.untyped)
  CURRENT_TIME = ::T.let(nil, ::T.untyped)
  CURRENT_TIMESTAMP = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  FALSE = ::T.let(nil, ::T.untyped)
  NOTNULL = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  SQLFALSE = ::T.let(nil, ::T.untyped)
  SQLTRUE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

module Sequel::SQL::Constants
end

class Sequel::SQL::DelayedEvaluation
  def call(ds); end

  def callable(); end

  def initialize(callable); end

  def to_s_append(ds, sql); end
end

class Sequel::SQL::DelayedEvaluation
end

class Sequel::SQL::Expression
  def ==(other); end

  def clone(); end

  def eql?(other); end
end

class Sequel::SQL::Expression
  def self.attr_reader(*args); end

  def self.comparison_attrs(); end

  def self.inherited(subclass); end
end

class Sequel::SQL::Function
  def *(ce=T.unsafe(nil)); end

  def args(); end

  def distinct(); end

  def filter(*args, &block); end

  def initialize(name, *args); end

  def lateral(); end

  def name(); end

  def opts(); end

  def order(*args); end

  def over(window=T.unsafe(nil)); end

  def quoted(); end

  def to_s_append(ds, sql); end

  def unquoted(); end

  def with_ordinality(); end

  def within_group(*expressions); end
  COMMA_ARRAY = ::T.let(nil, ::T.untyped)
  DISTINCT = ::T.let(nil, ::T.untyped)
  WILDCARD = ::T.let(nil, ::T.untyped)
end

class Sequel::SQL::Function
  def self.new!(name, args, opts); end
end

class Sequel::SQL::GenericExpression
  include ::Sequel::SQL::AliasMethods
  include ::Sequel::SQL::BooleanMethods
  include ::Sequel::SQL::CastMethods
  include ::Sequel::SQL::ComplexExpressionMethods
  include ::Sequel::SQL::InequalityMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::OrderMethods
  include ::Sequel::SQL::PatternMatchMethods
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::SubscriptMethods
end

class Sequel::SQL::GenericExpression
end

class Sequel::SQL::Identifier
  include ::Sequel::SQL::QualifyingMethods
  def function(*args); end

  def initialize(value); end

  def to_s_append(ds, sql); end

  def value(); end
end

class Sequel::SQL::Identifier
end

module Sequel::SQL::InequalityMethods
  def <(o); end

  def <=(o); end

  def >(o); end

  def >=(o); end
end

module Sequel::SQL::InequalityMethods
end

class Sequel::SQL::JoinClause
  def column_aliases(); end

  def initialize(join_type, table_expr); end

  def join_type(); end

  def table(); end

  def table_alias(); end

  def table_expr(); end

  def to_s_append(ds, sql); end
end

class Sequel::SQL::JoinClause
end

class Sequel::SQL::JoinOnClause
  def initialize(on, *args); end

  def on(); end
end

class Sequel::SQL::JoinOnClause
end

class Sequel::SQL::JoinUsingClause
  def initialize(cols, *args); end

  def using(); end
end

class Sequel::SQL::JoinUsingClause
end

class Sequel::SQL::NegativeBooleanConstant
end

class Sequel::SQL::NegativeBooleanConstant
end

class Sequel::SQL::NumericExpression
  include ::Sequel::SQL::BitwiseMethods
  include ::Sequel::SQL::NumericMethods
  include ::Sequel::SQL::InequalityMethods
end

class Sequel::SQL::NumericExpression
end

module Sequel::SQL::NumericMethods
  def *(o); end

  def **(o); end

  def +(ce); end

  def -(o); end

  def /(o); end

  def coerce(other); end
end

module Sequel::SQL::NumericMethods
end

module Sequel::SQL::OperatorBuilders
  def &(*args); end

  def *(*args); end

  def **(a, b); end

  def +(*args); end

  def -(*args); end

  def /(*args); end

  def |(*args); end

  def ~(arg); end
end

module Sequel::SQL::OperatorBuilders
end

module Sequel::SQL::OrderMethods
  def asc(opts=T.unsafe(nil)); end

  def desc(opts=T.unsafe(nil)); end
end

module Sequel::SQL::OrderMethods
end

class Sequel::SQL::OrderedExpression
  def asc(); end

  def desc(); end

  def descending(); end

  def expression(); end

  def initialize(expression, descending=T.unsafe(nil), opts=T.unsafe(nil)); end

  def invert(); end

  def nulls(); end

  def to_s_append(ds, sql); end
  INVERT_NULLS = ::T.let(nil, ::T.untyped)
end

class Sequel::SQL::OrderedExpression
end

module Sequel::SQL::PatternMatchMethods
  def !~(other); end

  def =~(other); end
end

module Sequel::SQL::PatternMatchMethods
end

class Sequel::SQL::PlaceholderLiteralString
  def args(); end

  def initialize(str, args, parens=T.unsafe(nil)); end

  def parens(); end

  def str(); end

  def to_s_append(ds, sql); end

  def with_parens(); end
end

class Sequel::SQL::PlaceholderLiteralString
end

class Sequel::SQL::QualifiedIdentifier
  include ::Sequel::SQL::QualifyingMethods
  def column(); end

  def function(*args); end

  def initialize(table, column); end

  def table(); end

  def to_s_append(ds, sql); end
end

class Sequel::SQL::QualifiedIdentifier
end

module Sequel::SQL::QualifyingMethods
  def *(ce=T.unsafe(nil)); end

  def [](identifier); end

  def qualify(qualifier); end
end

module Sequel::SQL::QualifyingMethods
end

module Sequel::SQL::StringConcatenationMethods
  def +(ce); end
end

module Sequel::SQL::StringConcatenationMethods
end

class Sequel::SQL::StringExpression
  include ::Sequel::SQL::StringMethods
  include ::Sequel::SQL::StringConcatenationMethods
  include ::Sequel::SQL::InequalityMethods
  LIKE_MAP = ::T.let(nil, ::T.untyped)
end

class Sequel::SQL::StringExpression
  def self.like(l, *ces); end
end

module Sequel::SQL::StringMethods
  def ilike(*ces); end

  def like(*ces); end
end

module Sequel::SQL::StringMethods
end

class Sequel::SQL::Subscript
  def [](sub); end

  def expression(); end

  def f(); end

  def initialize(expression, sub); end

  def sub(); end

  def to_s_append(ds, sql); end

  def |(sub); end
end

class Sequel::SQL::Subscript
end

module Sequel::SQL::SubscriptMethods
  def sql_subscript(*sub); end
end

module Sequel::SQL::SubscriptMethods
end

class Sequel::SQL::ValueList
end

class Sequel::SQL::ValueList
end

class Sequel::SQL::VirtualRow
  include ::Sequel::SQL::OperatorBuilders
  def <(*args); end

  def <=(*args); end

  def >(*args); end

  def >=(*args); end
end

class Sequel::SQL::VirtualRow
end

class Sequel::SQL::Window
  def initialize(opts=T.unsafe(nil)); end

  def opts(); end

  def to_s_append(ds, sql); end
end

class Sequel::SQL::Window
end

class Sequel::SQL::Wrapper
  def initialize(value); end

  def to_s_append(ds, sql); end

  def value(); end
end

class Sequel::SQL::Wrapper
end

module Sequel::SQL
end

class Sequel::SQLTime
  def to_s(*args); end
end

class Sequel::SQLTime
  def self.create(hour, minute, second, usec=T.unsafe(nil)); end

  def self.date(); end

  def self.date=(date); end

  def self.parse(*_); end
end

module Sequel::Schema
end

class Sequel::Schema::AlterTableGenerator
  def add_column(name, type, opts=T.unsafe(nil)); end

  def add_constraint(name, *args, &block); end

  def add_foreign_key(name, table, opts=T.unsafe(nil)); end

  def add_full_text_index(columns, opts=T.unsafe(nil)); end

  def add_index(columns, opts=T.unsafe(nil)); end

  def add_primary_key(name, opts=T.unsafe(nil)); end

  def add_spatial_index(columns, opts=T.unsafe(nil)); end

  def add_unique_constraint(columns, opts=T.unsafe(nil)); end

  def drop_column(name, opts=T.unsafe(nil)); end

  def drop_constraint(name, opts=T.unsafe(nil)); end

  def drop_foreign_key(name, opts=T.unsafe(nil)); end

  def drop_index(columns, options=T.unsafe(nil)); end

  def initialize(db, &block); end

  def operations(); end

  def rename_column(name, new_name, opts=T.unsafe(nil)); end

  def set_column_allow_null(name, allow_null=T.unsafe(nil)); end

  def set_column_default(name, default); end

  def set_column_not_null(name); end

  def set_column_type(name, type, opts=T.unsafe(nil)); end
end

class Sequel::Schema::AlterTableGenerator
end

class Sequel::Schema::CreateTableGenerator
  def BigDecimal(name, opts=T.unsafe(nil)); end

  def Bignum(name, opts=T.unsafe(nil)); end

  def Date(name, opts=T.unsafe(nil)); end

  def DateTime(name, opts=T.unsafe(nil)); end

  def FalseClass(name, opts=T.unsafe(nil)); end

  def File(name, opts=T.unsafe(nil)); end

  def Fixnum(name, opts=T.unsafe(nil)); end

  def Float(name, opts=T.unsafe(nil)); end

  def Integer(name, opts=T.unsafe(nil)); end

  def Numeric(name, opts=T.unsafe(nil)); end

  def String(name, opts=T.unsafe(nil)); end

  def Time(name, opts=T.unsafe(nil)); end

  def TrueClass(name, opts=T.unsafe(nil)); end

  def check(*args, &block); end

  def column(name, type, opts=T.unsafe(nil)); end

  def columns(); end

  def constraint(name, *args, &block); end

  def constraints(); end

  def foreign_key(name, table=T.unsafe(nil), opts=T.unsafe(nil)); end

  def full_text_index(columns, opts=T.unsafe(nil)); end

  def has_column?(name); end

  def index(columns, opts=T.unsafe(nil)); end

  def indexes(); end

  def initialize(db, &block); end

  def method_missing(type, name=T.unsafe(nil), opts=T.unsafe(nil)); end

  def primary_key(name, *args); end

  def primary_key_name(); end

  def spatial_index(columns, opts=T.unsafe(nil)); end

  def unique(columns, opts=T.unsafe(nil)); end
  GENERIC_TYPES = ::T.let(nil, ::T.untyped)
end

class Sequel::Schema::CreateTableGenerator
  def self.add_type_method(*types); end
end

module Sequel::Schema
end

class Sequel::SerializationFailure
end

class Sequel::SerializationFailure
end

module Sequel::Timezones
  def application_timezone(); end

  def application_timezone=(tz); end

  def application_to_database_timestamp(v); end

  def convert_output_timestamp(v, output_timezone); end

  def convert_timestamp(v, input_timezone); end

  def database_timezone(); end

  def database_timezone=(tz); end

  def database_to_application_timestamp(v); end

  def default_timezone=(tz); end

  def typecast_timezone(); end

  def typecast_timezone=(tz); end

  def typecast_to_application_timestamp(v); end
end

module Sequel::Timezones
end

class Sequel::UndefinedAssociation
end

class Sequel::UndefinedAssociation
end

class Sequel::UniqueConstraintViolation
end

class Sequel::UniqueConstraintViolation
end

class Sequel::ValidationFailed
  def errors(); end

  def initialize(errors=T.unsafe(nil)); end

  def model(); end
end

class Sequel::ValidationFailed
end

module Sequel
  extend ::Sequel::SQL::Builders
  extend ::Sequel::SQL::OperatorBuilders
  extend ::Sequel::Timezones
  def self.Model(source); end

  def self.[](arg=T.unsafe(nil), &block); end

  def self.ado(*args, &block); end

  def self.amalgalite(*args, &block); end

  def self.condition_specifier?(obj); end

  def self.connect(*args, &block); end

  def self.convert_exception_class(exception, klass); end

  def self.convert_two_digit_years(); end

  def self.convert_two_digit_years=(convert_two_digit_years); end

  def self.core_extensions?(); end

  def self.datetime_class(); end

  def self.datetime_class=(datetime_class); end

  def self.elapsed_seconds_since(timer); end

  def self.extension(*extensions); end

  def self.ibmdb(*args, &block); end

  def self.inflections(); end

  def self.jdbc(*args, &block); end

  def self.json_parser_error_class(); end

  def self.mock(*args, &block); end

  def self.mysql(*args, &block); end

  def self.mysql2(*args, &block); end

  def self.object_to_json(obj, *args, &block); end

  def self.odbc(*args, &block); end

  def self.oracle(*args, &block); end

  def self.parse_json(json); end

  def self.postgres(*args, &block); end

  def self.recursive_map(array, converter); end

  def self.require(files, subdir=T.unsafe(nil)); end

  def self.single_threaded(); end

  def self.single_threaded=(single_threaded); end

  def self.split_symbol(sym); end

  def self.split_symbols=(v); end

  def self.split_symbols?(); end

  def self.sqlanywhere(*args, &block); end

  def self.sqlite(*args, &block); end

  def self.start_timer(); end

  def self.string_to_date(string); end

  def self.string_to_datetime(string); end

  def self.string_to_time(string); end

  def self.synchronize(&block); end

  def self.tinytds(*args, &block); end

  def self.transaction(dbs, opts=T.unsafe(nil), &block); end

  def self.version(); end

  def self.virtual_row(&block); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_method(obj, sym); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::ToRegexp::String
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def ext(newext=T.unsafe(nil)); end

  def grapheme_clusters(); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def shrink(width, ellipses=T.unsafe(nil)); end

  def succ!(); end

  def to_blob(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

module Syslog
  include ::Syslog::Constants
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
end

module Syslog::Constants
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
end

module Syslog::Constants
  extend ::Syslog::Macros
end

module Syslog::Facility
  LOG_AUTH = ::T.let(nil, ::T.untyped)
  LOG_AUTHPRIV = ::T.let(nil, ::T.untyped)
  LOG_CRON = ::T.let(nil, ::T.untyped)
  LOG_DAEMON = ::T.let(nil, ::T.untyped)
  LOG_FTP = ::T.let(nil, ::T.untyped)
  LOG_KERN = ::T.let(nil, ::T.untyped)
  LOG_LOCAL0 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL1 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL2 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL3 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL4 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL5 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL6 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL7 = ::T.let(nil, ::T.untyped)
  LOG_LPR = ::T.let(nil, ::T.untyped)
  LOG_MAIL = ::T.let(nil, ::T.untyped)
  LOG_NEWS = ::T.let(nil, ::T.untyped)
  LOG_SYSLOG = ::T.let(nil, ::T.untyped)
  LOG_USER = ::T.let(nil, ::T.untyped)
  LOG_UUCP = ::T.let(nil, ::T.untyped)
end

module Syslog::Facility
end

module Syslog::Level
  LOG_ALERT = ::T.let(nil, ::T.untyped)
  LOG_CRIT = ::T.let(nil, ::T.untyped)
  LOG_DEBUG = ::T.let(nil, ::T.untyped)
  LOG_EMERG = ::T.let(nil, ::T.untyped)
  LOG_ERR = ::T.let(nil, ::T.untyped)
  LOG_INFO = ::T.let(nil, ::T.untyped)
  LOG_NOTICE = ::T.let(nil, ::T.untyped)
  LOG_WARNING = ::T.let(nil, ::T.untyped)
end

module Syslog::Level
end

module Syslog::Macros
  def LOG_MASK(_); end

  def LOG_UPTO(_); end
end

module Syslog::Macros
end

module Syslog::Option
  LOG_CONS = ::T.let(nil, ::T.untyped)
  LOG_NDELAY = ::T.let(nil, ::T.untyped)
  LOG_NOWAIT = ::T.let(nil, ::T.untyped)
  LOG_ODELAY = ::T.let(nil, ::T.untyped)
  LOG_PERROR = ::T.let(nil, ::T.untyped)
  LOG_PID = ::T.let(nil, ::T.untyped)
end

module Syslog::Option
end

module Syslog
  extend ::Syslog::Macros
  def self.alert(*_); end

  def self.close(); end

  def self.crit(*_); end

  def self.debug(*_); end

  def self.emerg(*_); end

  def self.err(*_); end

  def self.facility(); end

  def self.ident(); end

  def self.info(*_); end

  def self.instance(); end

  def self.log(*_); end

  def self.mask(); end

  def self.mask=(mask); end

  def self.notice(*_); end

  def self.open!(*_); end

  def self.opened?(); end

  def self.options(); end

  def self.reopen(*_); end

  def self.warning(*_); end
end

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

class TZInfo::AmbiguousTime
end

class TZInfo::AmbiguousTime
end

class TZInfo::Country
  include ::Comparable
  def =~(regexp); end

  def _dump(limit); end

  def code(); end

  def eql?(c); end

  def initialize(info); end

  def name(); end

  def zone_identifiers(); end

  def zone_info(); end

  def zone_names(); end

  def zones(); end
end

class TZInfo::Country
  def self._load(data); end

  def self.all(); end

  def self.all_codes(); end

  def self.get(code); end
end

class TZInfo::CountryTimezone
  def ==(ct); end

  def description(); end

  def description_or_friendly_identifier(); end

  def eql?(ct); end

  def identifier(); end

  def initialize(identifier, latitude, longitude, description=T.unsafe(nil)); end

  def latitude(); end

  def longitude(); end

  def timezone(); end
end

class TZInfo::CountryTimezone
end

class TZInfo::DataSource
  def country_codes(); end

  def data_timezone_identifiers(); end

  def get_country_info(code); end

  def get_timezone_info(identifier); end

  def linked_timezone_identifiers(); end

  def load_country_info(code); end

  def load_timezone_info(identifier); end

  def lookup_country_info(hash, code, encoding=T.unsafe(nil)); end

  def timezone_identifier_encoding(); end

  def timezone_identifiers(); end

  def validate_timezone_identifier(identifier); end
end

class TZInfo::DataSource
  def self.get(); end

  def self.set(data_source_or_type, *args); end
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataSourceNotFound
end

module TZInfo::DataSources
end

class TZInfo::DataSources::ConstantOffsetDataTimezoneInfo
  def constant_offset(); end

  def initialize(identifier, constant_offset); end
end

class TZInfo::DataSources::ConstantOffsetDataTimezoneInfo
end

class TZInfo::DataSources::CountryInfo
  def code(); end

  def initialize(code, name, zones); end

  def name(); end

  def zones(); end
end

class TZInfo::DataSources::CountryInfo
end

class TZInfo::DataSources::DataTimezoneInfo
  def period_for(timestamp); end

  def periods_for_local(local_timestamp); end

  def transitions_up_to(to_timestamp, from_timestamp=T.unsafe(nil)); end
end

class TZInfo::DataSources::DataTimezoneInfo
end

class TZInfo::DataSources::InvalidZoneinfoDirectory
end

class TZInfo::DataSources::InvalidZoneinfoDirectory
end

class TZInfo::DataSources::InvalidZoneinfoFile
end

class TZInfo::DataSources::InvalidZoneinfoFile
end

class TZInfo::DataSources::LinkedTimezoneInfo
  def initialize(identifier, link_to_identifier); end

  def link_to_identifier(); end
end

class TZInfo::DataSources::LinkedTimezoneInfo
end

class TZInfo::DataSources::RubyDataSource
end

class TZInfo::DataSources::RubyDataSource
end

class TZInfo::DataSources::TZInfoDataNotFound
end

class TZInfo::DataSources::TZInfoDataNotFound
end

class TZInfo::DataSources::TimezoneInfo
  def create_timezone(); end

  def identifier(); end

  def initialize(identifier); end
end

class TZInfo::DataSources::TimezoneInfo
end

class TZInfo::DataSources::TransitionsDataTimezoneInfo
  def initialize(identifier, transitions); end

  def transitions(); end
end

class TZInfo::DataSources::TransitionsDataTimezoneInfo
end

class TZInfo::DataSources::ZoneinfoDataSource
  def initialize(zoneinfo_dir=T.unsafe(nil), alternate_iso3166_tab_path=T.unsafe(nil)); end

  def zoneinfo_dir(); end
end

class TZInfo::DataSources::ZoneinfoDataSource
  def self.alternate_iso3166_tab_search_path(); end

  def self.alternate_iso3166_tab_search_path=(alternate_iso3166_tab_search_path); end

  def self.search_path(); end

  def self.search_path=(search_path); end
end

class TZInfo::DataSources::ZoneinfoDirectoryNotFound
end

class TZInfo::DataSources::ZoneinfoDirectoryNotFound
end

module TZInfo::DataSources
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezone
end

class TZInfo::DateTimeWithOffset
  include ::TZInfo::WithOffset
  def clear_timezone_offset(); end

  def downto(min); end

  def new_start(start=T.unsafe(nil)); end

  def set_timezone_offset(timezone_offset); end

  def step(limit, step=T.unsafe(nil)); end

  def timezone_offset(); end

  def upto(max); end
end

class TZInfo::DateTimeWithOffset
end

class TZInfo::InfoTimezone
  def info(); end

  def initialize(info); end
end

class TZInfo::InfoTimezone
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezone
end

class TZInfo::OffsetTimezonePeriod
  def ==(p); end

  def eql?(p); end
end

class TZInfo::OffsetTimezonePeriod
end

class TZInfo::PeriodNotFound
end

class TZInfo::PeriodNotFound
end

class TZInfo::TimeWithOffset
  include ::TZInfo::WithOffset
  def localtime(*args); end

  def round(ndigits=T.unsafe(nil)); end

  def set_timezone_offset(timezone_offset); end

  def timezone_offset(); end
end

class TZInfo::TimeWithOffset
end

class TZInfo::Timestamp
  include ::Comparable
  def add_and_set_utc_offset(seconds, utc_offset); end

  def initialize(value, sub_second=T.unsafe(nil), utc_offset=T.unsafe(nil)); end

  def new_datetime(klass=T.unsafe(nil)); end

  def new_time(klass=T.unsafe(nil)); end

  def strftime(format); end

  def sub_second(); end

  def to_datetime(); end

  def to_i(); end

  def to_time(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end

  def value(); end
end

class TZInfo::Timestamp
  def self.create(year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), minute=T.unsafe(nil), second=T.unsafe(nil), sub_second=T.unsafe(nil), utc_offset=T.unsafe(nil)); end

  def self.for(value, offset=T.unsafe(nil)); end

  def self.utc(value, sub_second=T.unsafe(nil)); end
end

class TZInfo::TimestampWithOffset
  include ::TZInfo::WithOffset
  def set_timezone_offset(timezone_offset); end

  def timezone_offset(); end
end

class TZInfo::TimestampWithOffset
  def self.set_timezone_offset(timestamp, timezone_offset); end
end

class TZInfo::Timezone
  include ::Comparable
  def =~(regexp); end

  def _dump(limit); end

  def abbr(time=T.unsafe(nil)); end

  def abbreviation(time=T.unsafe(nil)); end

  def base_utc_offset(time=T.unsafe(nil)); end

  def canonical_identifier(); end

  def canonical_zone(); end

  def current_period(); end

  def current_period_and_time(); end

  def current_time_and_period(); end

  def dst?(time=T.unsafe(nil)); end

  def eql?(tz); end

  def friendly_identifier(skip_first_part=T.unsafe(nil)); end

  def identifier(); end

  def local_datetime(year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), minute=T.unsafe(nil), second=T.unsafe(nil), sub_second=T.unsafe(nil), dst=T.unsafe(nil), &block); end

  def local_time(year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), minute=T.unsafe(nil), second=T.unsafe(nil), sub_second=T.unsafe(nil), dst=T.unsafe(nil), &block); end

  def local_timestamp(year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), minute=T.unsafe(nil), second=T.unsafe(nil), sub_second=T.unsafe(nil), dst=T.unsafe(nil), &block); end

  def local_to_utc(local_time, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def observed_utc_offset(time=T.unsafe(nil)); end

  def offsets_up_to(to, from=T.unsafe(nil)); end

  def period_for(time); end

  def period_for_local(local_time, dst=T.unsafe(nil)); end

  def period_for_utc(utc_time); end

  def periods_for_local(local_time); end

  def strftime(format, time=T.unsafe(nil)); end

  def to_local(time); end

  def transitions_up_to(to, from=T.unsafe(nil)); end

  def utc_offset(time=T.unsafe(nil)); end

  def utc_to_local(utc_time); end
end

class TZInfo::Timezone
  def self._load(data); end

  def self.all(); end

  def self.all_country_zone_identifiers(); end

  def self.all_country_zones(); end

  def self.all_data_zone_identifiers(); end

  def self.all_data_zones(); end

  def self.all_identifiers(); end

  def self.all_linked_zone_identifiers(); end

  def self.all_linked_zones(); end

  def self.default_dst(); end

  def self.default_dst=(value); end

  def self.get(identifier); end

  def self.get_proxy(identifier); end
end

class TZInfo::TimezoneOffset
  def ==(toi); end

  def abbr(); end

  def abbreviation(); end

  def base_utc_offset(); end

  def dst?(); end

  def eql?(toi); end

  def initialize(base_utc_offset, std_offset, abbreviation); end

  def observed_utc_offset(); end

  def std_offset(); end

  def utc_offset(); end

  def utc_total_offset(); end
end

class TZInfo::TimezoneOffset
end

class TZInfo::TimezonePeriod
  def abbr(); end

  def abbreviation(); end

  def base_utc_offset(); end

  def dst?(); end

  def end_transition(); end

  def ends_at(); end

  def initialize(offset); end

  def local_ends_at(); end

  def local_starts_at(); end

  def observed_utc_offset(); end

  def offset(); end

  def start_transition(); end

  def starts_at(); end

  def std_offset(); end

  def utc_offset(); end

  def utc_total_offset(); end

  def zone_identifier(); end
end

class TZInfo::TimezonePeriod
end

class TZInfo::TimezoneProxy
  def initialize(identifier); end
end

class TZInfo::TimezoneProxy
end

class TZInfo::TimezoneTransition
  def ==(tti); end

  def at(); end

  def eql?(tti); end

  def initialize(offset, previous_offset, timestamp_value); end

  def local_end_at(); end

  def local_start_at(); end

  def offset(); end

  def previous_offset(); end

  def timestamp_value(); end
end

class TZInfo::TimezoneTransition
end

class TZInfo::TransitionsTimezonePeriod
  def ==(p); end

  def eql?(p); end

  def initialize(start_transition, end_transition); end
end

class TZInfo::TransitionsTimezonePeriod
end

class TZInfo::UnknownTimezone
end

class TZInfo::UnknownTimezone
end

module TZInfo::WithOffset
  def if_timezone_offset(result=T.unsafe(nil)); end

  def strftime(format); end
end

module TZInfo::WithOffset
end

module TZInfo
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thread
  def self.new(*a, &b); end
end

module ToRegexp
end

module ToRegexp::Regexp
  def to_regexp(); end
end

module ToRegexp::Regexp
end

module ToRegexp::String
  def as_regexp(options=T.unsafe(nil)); end

  def to_regexp(options=T.unsafe(nil)); end
  INLINE_OPTIONS = ::T.let(nil, ::T.untyped)
  REGEXP_DELIMITERS = ::T.let(nil, ::T.untyped)
end

module ToRegexp::String
  def self.literal?(str); end
end

module ToRegexp
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  include ::MethodSource::SourceLocation::UnboundMethodExtensions
  include ::MethodSource::MethodExtensions
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

class XmlSimple
  include ::REXML
  def initialize(defaults=T.unsafe(nil)); end

  def xml_in(string=T.unsafe(nil), options=T.unsafe(nil)); end

  def xml_out(ref, options=T.unsafe(nil)); end
  DEF_ANONYMOUS_TAG = ::T.let(nil, ::T.untyped)
  DEF_ATTR_TO_SYMBOL = ::T.let(nil, ::T.untyped)
  DEF_CONTENT_KEY = ::T.let(nil, ::T.untyped)
  DEF_FORCE_ARRAY = ::T.let(nil, ::T.untyped)
  DEF_INDENTATION = ::T.let(nil, ::T.untyped)
  DEF_KEY_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  DEF_KEY_TO_SYMBOL = ::T.let(nil, ::T.untyped)
  DEF_ROOT_NAME = ::T.let(nil, ::T.untyped)
  DEF_XML_DECLARATION = ::T.let(nil, ::T.untyped)
  KNOWN_OPTIONS = ::T.let(nil, ::T.untyped)
end

class XmlSimple::Cache
  def restore_mem_copy(filename); end

  def restore_mem_share(filename); end

  def restore_storable(filename); end

  def save_mem_copy(data, filename); end

  def save_mem_share(data, filename); end

  def save_storable(data, filename); end
end

class XmlSimple::Cache
end

class XmlSimple
  def self.xml_in(string=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.xml_out(hash, options=T.unsafe(nil)); end
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
